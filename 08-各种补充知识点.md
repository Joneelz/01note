## 1、WebSocket——socket.io

### 1.1、服务端

  a.先有个http服务

```javascript
let server=http.createServer();
    server.listen(4311); 
```

  b.再有个ws服务

```javascript
   let wsServer=io.listen(server);
    wsServer.on('connection', function (sock){
      sock
    })
```

### 1.2、浏览器

  a.引库

   ` <script src="xxxx/socket.io/socket.io.js"></script>`

  b.连接
   ` let sock=io.connect('ws://xxxx/');`

### 1.3、传递数据

```js
浏览器或服务端可通过如下方法传递数据：
sock.emit('名字', 参数...);
sock.on('名字', function (参数...){});
```

### 1.4、连接断开或离线

```javascript
sock.on('disconnect',function(){	 //会触发
    console.log('连续断开')
})
```



## 2、promise封装

~~~javascript
    class Promise2{
      constructor(fn){
        const _this=this;
        //重点
        this.__queue=[];
        this.__succ_res=null;
        this.__erro_res=null;
        this.status='';
        fn(function (...arg){
          _this.__succ_res=arg;
          _this.status='succ';
          _this.__queue.forEach(json=>{
            json.fn1(...arg);
          });
        }, function (...arg){
          _this.__erro_res=arg;
          _this.status='error';
          _this.__queue.forEach(json=>{
            json.fn2(...arg);
          });
        });
      }
      then(fn1, fn2){
        if(this.status=='succ'){
          fn1(...this.__succ_res);
        }else if(this.status=='error'){
          fn2(...this.__erro_res);
        }else{
          this.__queue.push({fn1, fn2});
        }
      }
    }
    Promise2.all=function (arr){
      let arr=[];
      return Promise2(function (resolve, reject){
        let i=0;
        function next(){
          arr[i].then(function (res){
            arr.push(res);
            i++;
            if(i==arr.length){
              resolve(arr);
            }else{
              next();
            }
          }, reject);
        }
      });
    };

    let p=new Promise2(function (resolve, reject){
      setTimeout(function (){
        resolve(12);
      }, 500);
    });

    p.then(function (num){
      alert(num);
    }, function (){
      alert('错误');
    });

~~~

## 3、管理数据的可视图软件naticat

## 4、简单的SQL语句

### 4.1、增  	

```sql
INSERT INTO 表(字段列表) VALUES(值)
INSERT INTO user_table (username,password,online) VALUES ('张三','123456',0)
```

### 4.2、删

```sql
DELTE FROM 表 WHERE 条件
DELETE FROM　user_table WHERE ID=3
```

### 4.3、改

```sql
UPDATE 表 SET 字段=新值,字段=新值,…  WHERE 条件
UPDATE user_table SET password='111111111' WHERE ID=2
```

### 4.4、查

```sql
SELECT 字段列表 FROM 表 WHERE 条件
SELECT username,online FROM user_table WHERE ID=1
```

## 5、H5部分补充点

### 5.1 定位api的使用

```javascript
if(window.navigator.geolocation){                 // 获取地址
          navigator.geolocation.getCurrentPosition(function (res){
            alert('成功');
            console.log(res);
          }, function (err){
            alert('失败');
          }, {
            //enableHighAccuracy          //高精度模式
            //timeout                     //超时时间
            //maximumAge                  //缓存
          });
        }else{
          alert('你的浏览器不支持定位');
        }


if(window.navigator.geolocation){         //观察地址变化
          var watchID=navigator.geolocation.watchPosition(function (res){
            alert('成功');
            console.log(res);
          }, function (err){
            alert('失败');
          }, {
            //enableHighAccuracy          //高精度模式
            //timeout                     //超时时间
            //maximumAge                  //缓存
            //frequency:    1000  		 //定位更新频率
          });
        }else{
          alert('你的浏览器不支持定位');
        }

        //navigator.geolocation.clearWatch(watchID);
      
```

### 5.2 webworket多进程创建和使用

```javascript
// 不能执行任何UI操作，子进程只能执行计算型任务
    //1.创建子进程    主js文件创建
    let w=new Worker('w1.js');   // 引入js文件
    //2.发送
    w.postMessage({n1, n2});
    //6.接收结果
    w.onmessage=function (ev){
        alert(ev.data);
    };

    //3.接收 		w1.js文件
    this.onmessage=function (ev){
      //console.log('我得到了：', ev.data);
      //4.处理任务
      let sum=ev.data.n1+ev.data.n2;
      //5.返回
      this.postMessage(sum);
    };
```

### 5.3 拖拽事件

```javascript
oDiv.addEventListener('dragenter', function (){     //ondragenter     进入
    oDiv.innerHTML='释放鼠标';
}, false);

oDiv.addEventListener('dragleave', function (){     //ondragleave     离开
    oDiv.innerHTML='将文件拖拽至此区域';
}, false);

oDiv.addEventListener('dragover', function (ev){    //ondragover  悬停——只要没走，就一直发生
    console.log('dragover');
    ev.preventDefault();
}, false);

// 松开鼠标——如果dragover不阻止默认事件，drop压根不会发生
oDiv.addEventListener('drop', function (ev){
    console.log(ev.dataTransfer.files); // 获取传输的文件
    ev.preventDefault();
}, false);

```

### 5.4 文件操作相关

文件拖拽获取文件：ev.dataTransfer.files

使用input获取文件：oFile.files

```javascript
	oDiv.addEventListener('drop', function (ev){
        ev.preventDefault();
        //
        let oFile=ev.dataTransfer.files[0];
        //读取
        let reader=new FileReader();
        reader.onload=function (){
          console.log(this.result);
        };
        reader.onerror=function (){
          alert('读取失败了');
        };
        reader.readAsText(oFile)            //文本                    文本文件
        reader.readAsDataURL(oFile)         //base64                  图片
        reader.readAsArrayBuffer(oFile)     //原始二进制数据           编辑（不实用）
        reader.readAsBinaryString(oFile)    //二进制的文本形式数据     上传
      }, false);
```

### 5.5 canvas相关的操作补充

使用路径之前——先beginPath   与路径操作配合使用
使用变换之前——先save、后restore     与变形transform和rotale等配合使用

#### 5.5.1 canvas像素级操作

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title></title>
    <script>
    window.onload=function (){
      let oC=document.getElementById('c1');
      let oBtn1=document.getElementById('btn1');
      let oBtn2=document.getElementById('btn2');
      let oBtn3=document.getElementById('btn3');
      let gd=oC.getContext('2d');
      //每个像素占4位   r g b a         0~255
      let oImg=new Image();
      oImg.src='1.jpg';
      oImg.onload=function (){
        gd.drawImage(oImg, 0, 0);
        oBtn1.onclick=function (){
          let imageData=gd.getImageData(0, 0, oC.width, oC.height);    //获取像素区
          //data[(r*W+c)*4]
          for(let r=0;r<oC.height;r++){
            for(let c=0;c<oC.width;c++){
              let avg=(imageData.data[(r*oC.width+c)*4]+imageData.data[(r*oC.width+c)*4+1]+
                       imageData.data[(r*oC.width+c)*4+2])/3;
              imageData.data[(r*oC.width+c)*4]=imageData.data[(r*oC.width+c)*4+1]=
                  imageData.data[(r*oC.width+c)*4+2]=avg;
            }
          }
          gd.putImageData(imageData, 0, 0);
        };
        oBtn2.onclick=function (){
          let imageData=gd.getImageData(0, 0, oC.width, oC.height);       //获取像素区
          //data[(r*W+c)*4]
          for(let r=0;r<oC.height;r++){
            for(let c=0;c<oC.width;c++){
              imageData.data[(r*oC.width+c)*4+2]=0;
            }
          }
          gd.putImageData(imageData, 0, 0);        // 将修改后的图相重新画进canvas中
        };

        oBtn3.onclick=function (){
          let imageData=gd.getImageData(0, 0, oC.width, oC.height);  //获取像素区
          //data[(r*W+c)*4]
          for(let r=0;r<oC.height;r++){
            for(let c=0;c<oC.width;c++){
              imageData.data[(r*oC.width+c)*4+0]=0;
              imageData.data[(r*oC.width+c)*4+2]=0;
            }
          }
          gd.putImageData(imageData, 0, 0);    //修改
        };
      };
    };
    </script>
  </head>
  <body>
    <input type="button" name="" value="变灰" id="btn1">
    <input type="button" name="" value="变黄" id="btn2">
    <input type="button" name="" value="变绿" id="btn3"><br>
    <canvas id="c1" width="800" height="600"></canvas>
  </body>
</html>
```

#### 5.5.2 canvas画video

```javascript
<video id="v1" src="a.mp4" controls></video>
<canvas id="c1" width="636" height="360"></canvas>

let oV=document.getElementById('v1');   //获取video
let oC=document.getElementById('c1');   //获取canvas
let gd=oC.getContext('2d');			//获取画笔
gd.drawImage(oV, 0, 0);		//将video画进canvas中，此时只能画一帧，需设置定时器
```

使用requestAnimationFrame来处理视频（加滤镜等操作）

```javascript
 requestAnimationFrame(function (){
          //画
          gd.drawImage(oV, 0, 0);  //将视频画上

          //取
          let imageData=gd.getImageData(0, 0, oC.width, oC.height); //取该一帧的画面

          for(let r=0;r<oC.height;r++){
            for(let c=0;c<oC.width;c++){  //双循环来获取每个画面的像素点
              let color=(imageData.data[(r*oC.width+c)*4]+
                         imageData.data[(r*oC.width+c)*4+1]+
                         imageData.data[(r*oC.width+c)*4+2])/3 

              imageData.data[(r*oC.width+c)*4]=
              imageData.data[(r*oC.width+c)*4+1]=
              imageData.data[(r*oC.width+c)*4+2]=color;  //将每个像素点的颜色都进行处理
            }
          }
          gd.putImageData(imageData, 0, 0);	 //将更改后的像素点重画上
        })
```

#### 5.5.3 使用canvas画图传至服务端

```javascript
    let gd=oC.getContext('2d'); 
    let str=oC.toDataURL(); //1.将画好的图片转成base64字符串
    //2.发给服务器
    let xhr=new XMLHttpRequest();
    xhr.open('post', '/upload_base64', true);
    xhr.send(encodeURIComponent(str));   //base64位需编码
    xhr.onreadystatechange=function (){
        if(xhr.readyState==4){
            alert(xhr.status);
        }
    }
```

#### 5.5.4 将input获取的文件画在页面上

```javascript
let reader=new FileReader();
reader.onload=function (){
    let oImg=new Image();
    oImg.src=this.result;
    oImg.onload=function (){
        gd.drawImage(oImg, 0, 0);
    }
    reader.readAsDataURL(oF.files[0]);
}
```

#### 5.5.5 拖拽文件至页面上显示

```javascript
oBox.addEventListener('drop', function (ev){
    ev.preventDefault();
    //
    let formData=new FormData();
    Array.from(ev.dataTransfer.files).forEach(file=>{
        formData.append('f1', file);
    });
    
    //ajax
    let xhr=new XMLHttpRequest();
    xhr.upload.onprogress=function (ev){
        oM.value=Math.floor(100*ev.loaded/ev.total);
    };
    xhr.upload.onload=function (){
        alert('上传完成');
    };

    xhr.open('post', '/upload', true);
    xhr.send(formData);

    //服务器返回
    xhr.onreadystatechange=function (){
        if(xhr.readyState==4){
            alert(xhr.status);
        }
    };
}, false);
```



### 5.6 ajax上传文件等内容方法

ajax一切操作都是在模拟表单，一般使用FormData对象来构建表单

```js
oAjax.send(formData) //ajax发送FormData
formData.set(名字, 值); //form提供的方法，值可为file
formData.append(名字, 值); //form提供的方法，值可为file,append可增加多个文件
```

#### 5.6.1 上传进度实现

| onabort                            | 终止     |
| ---------------------------------- | -------- |
| onerror                            | 错误     |
| onload                             | 完成     |
| onloadstart                        | 开始     |
| onloadend                          | 结束     |
| onprogress(**ev.loaded/ev.total**) | 进度变化 |
| ontimeout                          | 超时     |

```javascript
    let oAjax=new XMLHttpRequest();
    //进度
    oAjax.upload.onerror=function (){   // upload方法要放在open方法前
        alert('上传出错，请稍候重试');
    };
    oAjax.upload.onload=function (){
        alert('上传完成');
    };
    oAjax.upload.onprogress=function (ev){ // ev.loaded/ev.total可以获取到进度
        let str=(100*ev.loaded/ev.total).toFixed(2)+'%'; 
        let oChild=document.querySelector('.child');
        oChild.style.width=str;
    };

    oAjax.open('POST', '/upload', true);

    //表单
    let formData=new FormData();
    aFile.forEach(oFile=>{
        Array.from(oFile.files).forEach(file=>{
            formData.append('f1', file);
        });
    });

    oAjax.send(formData);

    oAjax.onreadystatechange=function (){
        if(oAjax.readyState==4){
            alert(oAjax.status);
        }
```

#### 5.6.2 上传图片或文件时node的处理

```javascript
//读取文件 readFile(文件名, [编码,] cb)
const fs=require('fs');
fs.readFile('1.gif', 'base64', (err, data)=>{   
  if(err){
    console.log('读取失败');
  }else{
    console.log(data);
  }
});
//写入文件writeFile(文件名, 东西, [编码,] cb)
```

```javascript
//使用POST请求获取base64位格式的图片   GET	1个包   POST	n个包  post数据必须分很多次接收
const http=require('http');
let server=http.createServer((req, res)=>{
  //注意：下面的post接收方式有瑕疵
  let str='';
  req.on('data', data=>{
    str+=data;
  });
  req.on('end', ()=>{
    console.log('post数据接收完了', str);
  });
});
server.listen(8080);
```

```javascript
//一个完整的POST请求
const http=require('http');
const fs=require('fs');
const url=require('url');
const uuidv4=require('uuid/v4');

let server=http.createServer((req, res)=>{
  const {pathname, query}=url.parse(req.url, true);
  if(pathname=='/upload_base64'){
    //3.接收字符串
    let str='';       //问题不大——以后再改
    req.on('data', data=>{
      str+=data;
    });
    req.on('end', ()=>{
      str=decodeURIComponent(str);
      str=str.replace(/data:[a-z\-]+(\/[a-z\-]+)?;base64,/i, '');
      //4.保存下来
      fs.writeFile(`./www/upload/${uuidv4().replace(/\-/g, '')}`, str, 'base64', err=>{
        if(err){
          res.writeHeader(500);
          res.write('write file error');
        }else{
          res.write('ok');
        }
        res.end();
      });
    });
  }else{
    fs.readFile(`./www${pathname}`, (err, data)=>{
      if(err){
        res.writeHeader(404);
        res.write('not found');
      }else{
        res.write(data);
      }
      res.end();
    });
  }
});
server.listen(8080);
```



### 5.7 requestAnimationFrame()

```javascript
requestAnimationFrame(function (){   //向浏览器请求一帧，传递一个回调函数循环执行
    gd.drawImage(oV, 0, 0)		//每隔一帧执行一次该操作
 })
```




formData.set(名字, 值);
formData.append(名字, 值);















