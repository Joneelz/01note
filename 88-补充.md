```js
vscode常用插件：code runner(选中代码片段执行)  code spell Checker(单词拼写检查)
			  bracket Pair Colorizer(美化代码片段)
```

# 一、 javaScript 高级程序设计

## 1.1 获取当前获得了焦点的元素

```javascript
document.activeElement;
document.hasFocus(); // 获取当前元素是否获取了焦点
```

## 1.2 insertAdjacentHTML()方法

注意，这些值都必须是小写形式。第二个参数是一个 HTML 字符串（与 innerHTML 和 outerHTML
的值相同），如果浏览器无法解析该字符串，就会抛出错误。以下是这个方法的基本用法示例。

```javascript
 "beforebegin" ，在当前元素之前插入一个紧邻的同辈元素；
 "afterbegin"  ，在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素；
 "beforeend"   ，在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素；
 "afterend"    ，在当前元素之后插入一个紧邻的同辈元素。

//作为前一个同辈元素插入
element.insertAdjacentHTML("beforebegin", "<p>Hello world!</p>");
//作为第一个子元素插入
element.insertAdjacentHTML("afterbegin", "<p>Hello world!</p>");
//作为最后一个子元素插入
element.insertAdjacentHTML("beforeend", "<p>Hello world!</p>");
//作为后一个同辈元素插入
element.insertAdjacentHTML("afterend", "<p>Hello world!</p>")
```

## 1.3 scrollIntoView()方法的使用

注：凡是需要滚动的地方都加一句 scroll-behavior:smooth 就好

```js
如：html, body { scroll-behavior:smooth; }
```

```js
element.scrollIntoView(); // 等同于element.scrollIntoView(true)
element.scrollIntoView(alignToTop); // Boolean型参数
element.scrollIntoView(scrollIntoViewOptions); // Object型参数

// 语法
var element = document.getElementById("box");
element.scrollIntoView();
element.scrollIntoView(false);
element.scrollIntoView({block: "end"});
element.scrollIntoView({behavior: "instant", block: "end", inline: "nearest"});

behavior 可选   定义缓动动画， "auto", "instant", 或 "smooth" 之一。默认为 "auto"。
block 可选	  "start", "center", "end", 或 "nearest"之一。默认为 "start"。
inline 可选     "start", "center", "end", 或 "nearest"之一。默认为 "nearest"。
```

## 1.4 触发其它元素的事件

注：初始化事件对象可简写至 `event.initEvent("click", true, true); `

```js
//触发btn的点击事件
var btn = document.getElementById("myBtn");
//创建事件对象
var event = document.createEvent("MouseEvents");
//初始化事件对象
event.initMouseEvent(
  "click",
  true,
  true,
  document.defaultView,
  0,
  0,
  0,
  0,
  0,
  false,
  false,
  false,
  false,
  0,
  null
);
//触发事件
btn.dispatchEvent(event);

//触发textbox的键盘事件
var textbox = document.getElementById("myTextbox");
//以 DOM3 级方式创建事件对象
event = document.createEvent("KeyboardEvent");
//初始化事件对象
event.initKeyboardEvent(
  "keydown",
  true,
  true,
  document.defaultView,
  "a",
  0,
  "Shift",
  0
);
//触发事件
textbox.dispatchEvent(event);
```

## 1.5 操作剪切版

```js
6 个剪贴板事件。
 beforecopy ：在发生复制操作前触发。
 copy ：在发生复制操作时触发。
 beforecut ：在发生剪切操作前触发。
 cut ：在发生剪切操作时触发。
 beforepaste ：在发生粘贴操作前触发。
 paste ：在发生粘贴操作时触发。
```

## 1.6 操作富文本

主要使用 **` document.execCommand()`**。3 个参数：命令名称、false、值

| 命令          | 值（第三个参数） | 说明                           |
| ------------- | ---------------- | ------------------------------ |
| backcolor     | 颜色字符串       | 设置文档的背景颜色             |
| bold          | null             | 将选择的文本转换为粗体         |
| copy          | null             | 将选择的文本复制到剪贴板       |
| createlink    | URL 字符串       | 将选择的文本转换成一个链接     |
| cut           | null             | 将选择的文本剪切到剪贴板       |
| delete        | null             | 删除选择的文本                 |
| fontname      | 字体名称         | 将选择的文本修改为指定字体     |
| fontsize      | 1 ～ 7           | 将选择的文本修改为指定字体大小 |
| forecolor     | 颜色字符串       | 将选择的文本修改为指定的颜色   |
| italic        | null             | 将选择的文本转换成斜体         |
| justifycenter | null             | 将插入光标所在文本块居中对齐   |
| justifyleft   | null             | 将插入光标所在文本块左对齐     |
| underline     | null             | 为选择的文本添加下划线         |

```js
//转换粗体文本
document.execCommand("bold", false, null);
//转换斜体文本
document.execCommand("italic", false, null);
//创建指向 www.wrox.com 的链接
document.execCommand("createlink", false, "http://www.wrox.com");
//格式化为 1 级标题
document.execCommand("formatblock", false, "<h1>");
```

样关方法：

```js
//检测命令是否可以针对当前选择的文本
var result = 元素.document.queryCommandEnabled("bold"); //返回值为true或false
//是否已将指定命令应用到了选择的文本
var isBold = 元素.document.queryCommandState("bold"); //返回值为true或false
//取得执行命令时传入的值
var fontSize = 元素.document.queryCommandValue("fontsize"); //返回执行命令时传入的值
```

富文本选区

```js
var selection = frames["richedit"].getSelection(); //获取选区
var selectedText = selection.toString(); //取得选择的文本
var range = selection.getRangeAt(0); //取得代表选区的范围
var span = frames["richedit"].document.createElement("span"); //突出显示选择的文本
span.style.backgroundColor = "yellow";
range.surroundContents(span); //将选区添加到了带有黄色背景的 <span> 元素中
```

## 1.7 防篡改对象

### 1.7.1 不可扩展对象

不能再给对象添加属性和方法

```js
var person = { name: "Nicholas" };
Object.preventExtensions(person); //不能再给对象添加属性和方法
person.age = 29;
alert(person.age); //undefined
Object.istExtensible(person); //确定对象是否可以扩展
```

### 1.7.2 密封的对象

密封对象不可扩展，而且已有成员的 [[Configurable]] 特性将被设置为 false 。这就意味着不能删除属性和方法

```js
var person = { name: "Nicholas" };
Object.seal(person); //密封对象
person.age = 29;
alert(person.age); //undefined
delete person.name;
alert(person.name); //"Nicholas"
Object.isSealed(person); //确定对象是否被密封
```

### 1.7.3 冻结的对象

最严格的防篡改级别是冻结对象（frozen object）。冻结的对象既不可扩展，又是密封的，而且对象数据属性的 [[Writable]] 特性会被设置为 false

```js
var person = { name: "Nicholas" };
Object.freeze(person); //冻洁对象
person.age = 29;
alert(person.age); //undefined
delete person.name;
alert(person.name); //"Nicholas"
person.name = "Greg";
alert(person.name); //"Nicholas"
Object.isFrozen(person); //确定对象是否被冻洁
```

## 1.8 Page Visibility API

```js
 document.hidden ：表示页面是否隐藏的布尔值。页面隐藏包括页面在后台标签页中或者浏览器最小化。
 document.visibilityState ：表示下列 4 个可能状态的值。
  *页面在后台标签页中或浏览器最小化。
  *页面在前台标签页中。
  *实际的页面已经隐藏，但用户可以看到页面的预览（就像在 Windows 7 中，用户把鼠标移动到任务栏的图标上，就	  可以显示浏览器中当前页面的预览）。
  *页面在屏幕外执行预渲染处理。
 visibilitychange 事件：当文档从可见变为不可见或从不可见变为可见时，触发该事件。
```

## 1.9 JSONP 实现跨域请求

```javascript
function jsonp({ url, params, callback }) {
  //定义
  return new Promise((resolve, reject) => {
    let script = document.createElement("script");
    window[callback] = function (data) {
      resolve(data);
      document.body.removeChild(script);
    };
    script.onerror = function (error) {
      reject(data);
      document.body.removeChild(script);
    };
    params = { ...params, callback }; // wd=b&callback=show
    let arrs = [];
    for (let key in params) {
      arrs.push(`${key}=${params[key]}`);
    }
    script.src = `${url}?${arrs.join("&")}`;
    document.body.appendChild(script);
  });
}
jsonp({
  // 调用
  url: "http://localhost:3000/",
  params: { wd: "Iloveyou" },
  callback: "show",
})
  .then((data) => {
    console.log(data);
  })
  .catch((error) => {
    console.log(error);
  });

// server.js
let express = require("express");
let app = express();
app.get("/", function (req, res) {
  let { wd, callback } = req.query;
  console.log(wd); // Iloveyou
  console.log(callback); // show
  res.end(`${callback}('哈哈哈')`);
});
app.listen(3000, function () {
  console.log("app run port 3000");
});
```

## 2.0 URLSearchParams 使用方法

> - 处理 URL 的 query：

```javascript
let url = "?name=蔡&skill=篮球&year=2019";
let searchParams = new URLSearchParams(url);
for (let p of searchParams) {
  console.log(p);
} // ["wd", "蔡徐坤"]  // ["skill", "篮球"]  // ["year", "2019"]
searchParams.get("wd"); // "蔡"
searchParams.get("skill"); // "篮球"
searchParams.get("year"); // "2019"
searchParams.has("wd"); // true
searchParams.has("age"); // false
searchParams.append("age", 26);
searchParams.has("age"); // true
searchParams.get("age"); // 26
searchParams.delete("year");
searchParams.has("year"); // false
searchParams.set("skill", "篮球 唱 跳 rap");
searchParams.toString();
// "wd=蔡&skill=篮球+唱+跳+rap&year=2019&age=26"
```

## 2.1 **伪类与伪元素的区别**

- 伪类：更多的定义的是状态。常见的伪类有 :hover，:active，:focus，:visited，:link，:not，:firstchild，:last-child 等等。
- 伪元素：不存在 DOM 树中的虚拟元素，它们可以像正常的 html 元素一样定义 css，无法使用 JavaScript 获取。常见伪元素有 ::before，::after，::first-letter，::first-line 等等。

```html
<div class="t-collapse">
  <a class="collapse-target" href="#modal1">target 1</a>
  <a class="collapse-target" href="#modal2">target 2</a>
  <a class="collapse-target" href="#modal3">target 3</a>
  <a class="collapse-target" href="#modal4">target 4</a>
  <div class="collapse-body" id="modal1">target 1</div>
  <div class="collapse-body" id="modal2">target 2</div>
  <div class="collapse-body" id="modal3">target 3</div>
  <div class="collapse-body" id="modal4">target 4</div>
</div>
```

```css
.t-collapse > .collapse-body {
  display: none;
}
.t-collapse > .collapse-body:target {
  display: block;
}
```

## 2.2 js 随机排序方法使用

### 2.2.1 随机交换元素

- 遍历数组，每次循环都随机一个在数组长度范围内的数，并交换本次循环的位置和随机数位置上的元素

  ```js
  var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  function randSort1(arr) {
    for (var i = 0, len = arr.length; i < len; i++) {
      var rand = parseInt(Math.random() * len);
      var temp = arr[rand];
      arr[rand] = arr[i];
      arr[i] = temp;
    }
    return arr;
  }
  console.log(randSort1(arr));
  ```

###2.2.2 截取出随机数位置上的元素

- 申明一个新的空数组,利用 while 循环，如果数组长度大于 0，就继续循环；

- 每次循环都随机一个在数组长度范围内的数，将随机数位置上的元素 push 到新数组里，

- 并利用 splice 截取出随机数位置上的元素，同时也修改了原始数组的长度；

  ```js
  var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  function randSort(arr) {
    var mixedArray = [];
    while (arr.length > 0) {
      var randomIndex = parseInt(Math.random() * arr.length);
      mixedArray.push(arr[randomIndex]);
      arr.splice(randomIndex, 1);
    }
    return mixedArray;
  }
  console.log(randSort(arr));
  ```

### 2.2.3 利用传入 sort 排序中的比较函数

- 思路：利用传入 sort 排序中的比较函数,比较函数的规则如下：

1. 如果 compareFunction(a, b)的返回值 小于 0 ，那么 a 会被排列到 b 之前；

2. 如果 compareFunction(a, b)的返回值 等于 0 ，那么 a 和 b 的相对位置不变；

3. 如果 compareFunction(a, b)的返回值 大于 0 ，那么 b 会被排列到 a 之前；

```js
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
arr.sort(function () {
  return Math.random() - 0.5;
});
console.log(arr);
```

### 2.2.4 一个典型的 DOM 随机排序方法

```js
function randromSort(divname) {
  var randromArray = new Array();
  var i = 0;
  $("div[name=" + divname + "]").each(function () {
    randromArray[i] = $(this).clone(true);
    i = i + 1;
  });
  $("div[name=" + divname + "]").each(function () {
    var t = Math.floor(Math.random() * i);
    $(this).replaceWith(randromArray[t]);
    randromArray.splice(t, 1);
    i = i - 1;
  });
}
```

## 2.3 页面性能检测方法

```js
使用API: performance.getEntriesByType("navigati");
```

# 二、各种知识点

## 2.1 适配 iphoneX 刘海屏方法

方法 1，在 meta 标签中增加`viewport-fit=cover"`

`<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, viewport-fit=cover">`

方法 2，使用媒体查询：

```javascript
/*iPhoneX的适配*/
@media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) {
    html,bodey{
        height:812px
    }
}
```

##2.2 webpack 中 static 目录文件不打包

## 2.2、WebSocket——socket.io

### 2.2.1、服务端

a.先有个 http 服务

```javascript
let server = http.createServer();
server.listen(4311);
```

b.再有个 ws 服务

```javascript
let wsServer = io.listen(server);
wsServer.on("connection", function (sock) {
  sock;
});
```

### 2.2.2、浏览器

a.引库

<script src="xxxx/socket.io/socket.io.js"></script>

b.连接
let sock=io.connect('ws://xxxx/');

###2.2.3、传递数据

```js
浏览器或服务端可通过如下方法传递数据：
sock.emit('名字', 参数...);
sock.on('名字', function (参数...){});
```

###2.2.4、连接断开或离线

```javascript
sock.on("disconnect", function () {
  //会触发
  console.log("连续断开");
});
```

## 2.3 定位 api 的使用

```javascript
if (window.navigator.geolocation) {
  // 获取地址
  navigator.geolocation.getCurrentPosition(
    function (res) {
      alert("成功");
      console.log(res);
    },
    function (err) {
      alert("失败");
    },
    {
      //enableHighAccuracy          //高精度模式
      //timeout                     //超时时间
      //maximumAge                  //缓存
    }
  );
} else {
  alert("你的浏览器不支持定位");
}

if (window.navigator.geolocation) {
  //观察地址变化
  var watchID = navigator.geolocation.watchPosition(
    function (res) {
      alert("成功");
      console.log(res);
    },
    function (err) {
      alert("失败");
    },
    {
      //enableHighAccuracy          //高精度模式
      //timeout                     //超时时间
      //maximumAge                  //缓存
      //frequency:    1000  		 //定位更新频率
    }
  );
} else {
  alert("你的浏览器不支持定位");
}

//navigator.geolocation.clearWatch(watchID);
```

## 2.4 webworket 多进程创建和使用

> - 方法一

```javascript
// 不能执行任何UI操作，子进程只能执行计算型任务
//1.创建子进程    主js文件创建
let w = new Worker("w1.js"); // 引入js文件
//2.发送
w.postMessage({ n1, n2 });
//6.接收结果
w.onmessage = function (ev) {
  alert(ev.data);
};

//3.接收 		w1.js文件
this.onmessage = function (ev) {
  //console.log('我得到了：', ev.data);
  //4.处理任务
  let sum = ev.data.n1 + ev.data.n2;
  //5.返回
  this.postMessage(sum);
};
```

> - 方法二

```javascript
// nodejs中创建子进程     主进程文件
const http = require("http");
const fork = require("child_process").fork;
const server = http.createServer((req, res) => {
  if (req.url == "/compute") {
    const compute = fork("./fork_compute.js");
    compute.send("开启一个新的子进程");
    // 当一个子进程使用 process.send() 发送消息时会触发 'message' 事件
    compute.on("message", (sum) => {
      res.end(`Sum is ${sum}`);
      compute.kill();
    });

    // 子进程监听到一些错误消息退出
    compute.on("close", (code, signal) => {
      console.log(
        `收到close事件，子进程收到信号 ${signal} 而终止，退出码 ${code}`
      );
      compute.kill();
    });
  } else {
    res.end(`ok`);
  }
});
server.listen(3000, () => {
  console.log(
    "server started at http://127.0.0.1:3000" + "serverPID=" + process.pid
  );
});

// 子进程文件
const computation = () => {
  let sum = 0;
  console.info("计算开始");
  console.time("计算耗时");
  for (let i = 0; i < 1e10; i++) {
    sum += i;
  }
  console.info("计算结束");
  console.timeEnd("计算耗时");
  return sum;
};

process.on("message", (msg) => {
  console.log(msg, "process.pid", process.pid); // 子进程id
  const sum = computation();
  // 如果Node.js进程是通过进程间通信产生的，那么，process.send()方法可以用来给父进程发送消息
  process.send(sum);
});
```

## 2.5 拖拽事件

```javascript
oDiv.addEventListener(
  "dragenter",
  function () {
    //ondragenter     进入
    oDiv.innerHTML = "释放鼠标";
  },
  false
);

oDiv.addEventListener(
  "dragleave",
  function () {
    //ondragleave     离开
    oDiv.innerHTML = "将文件拖拽至此区域";
  },
  false
);

oDiv.addEventListener(
  "dragover",
  function (ev) {
    //ondragover  悬停——只要没走，就一直发生
    console.log("dragover");
    ev.preventDefault();
  },
  false
);

// 松开鼠标——如果dragover不阻止默认事件，drop压根不会发生
oDiv.addEventListener(
  "drop",
  function (ev) {
    console.log(ev.dataTransfer.files); // 获取传输的文件
    ev.preventDefault();
  },
  false
);
```

## 2.6 文件操作相关

```javascript
oDiv.addEventListener(
  "drop",
  function (ev) {
    ev.preventDefault();
    //
    let oFile = ev.dataTransfer.files[0];
    //读取
    let reader = new FileReader();
    reader.onload = function () {
      console.log(this.result);
    };
    reader.onerror = function () {
      alert("读取失败了");
    };
    reader.readAsText(oFile); //文本                    文本文件
    reader.readAsDataURL(oFile); //base64                  图片
    reader.readAsArrayBuffer(oFile); //原始二进制数据           编辑（不实用）
    reader.readAsBinaryString(oFile); //二进制的文本形式数据     上传
  },
  false
);
```

## 2.7canvas 相关的操作补充

使用路径之前——先 beginPath 与路径操作配合使用
使用变换之前——先 save、后 restore 与变形 transform 和 rotale 等配合使用

### 2.7.1 canvas 像素级操作

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title></title>
    <script>
      window.onload = function () {
        let oC = document.getElementById("c1");
        let oBtn1 = document.getElementById("btn1");
        let oBtn2 = document.getElementById("btn2");
        let oBtn3 = document.getElementById("btn3");
        let gd = oC.getContext("2d");
        //每个像素占4位   r g b a         0~255
        let oImg = new Image();
        oImg.src = "1.jpg";
        oImg.onload = function () {
          gd.drawImage(oImg, 0, 0);
          oBtn1.onclick = function () {
            let imageData = gd.getImageData(0, 0, oC.width, oC.height); //获取像素区
            //data[(r*W+c)*4]
            for (let r = 0; r < oC.height; r++) {
              for (let c = 0; c < oC.width; c++) {
                let avg =
                  (imageData.data[(r * oC.width + c) * 4] +
                    imageData.data[(r * oC.width + c) * 4 + 1] +
                    imageData.data[(r * oC.width + c) * 4 + 2]) /
                  3;
                imageData.data[(r * oC.width + c) * 4] =
                  imageData.data[(r * oC.width + c) * 4 + 1] =
                  imageData.data[(r * oC.width + c) * 4 + 2] =
                    avg;
              }
            }
            gd.putImageData(imageData, 0, 0);
          };
          oBtn2.onclick = function () {
            let imageData = gd.getImageData(0, 0, oC.width, oC.height); //获取像素区
            //data[(r*W+c)*4]
            for (let r = 0; r < oC.height; r++) {
              for (let c = 0; c < oC.width; c++) {
                imageData.data[(r * oC.width + c) * 4 + 2] = 0;
              }
            }
            gd.putImageData(imageData, 0, 0);
          };

          oBtn3.onclick = function () {
            let imageData = gd.getImageData(0, 0, oC.width, oC.height); //获取像素区
            //data[(r*W+c)*4]
            for (let r = 0; r < oC.height; r++) {
              for (let c = 0; c < oC.width; c++) {
                imageData.data[(r * oC.width + c) * 4 + 0] = 0;
                imageData.data[(r * oC.width + c) * 4 + 2] = 0;
              }
            }
            gd.putImageData(imageData, 0, 0);
          };
        };
      };
    </script>
  </head>
  <body>
    <input type="button" name="" value="变灰" id="btn1" />
    <input type="button" name="" value="变黄" id="btn2" />
    <input type="button" name="" value="变绿" id="btn3" /><br />
    <canvas id="c1" width="800" height="600"></canvas>
  </body>
</html>
```

### 2.7.2 canvas 画 video

```javascript
<video id="v1" src="a.mp4" controls></video>
<canvas id="c1" width="636" height="360"></canvas>

let oV=document.getElementById('v1');   //获取video
let oC=document.getElementById('c1');   //获取canvas
let gd=oC.getContext('2d');			//获取画笔
gd.drawImage(oV, 0, 0);		//将video画进canvas中，此时只能画一帧，需设置定时器
```

使用 requestAnimationFrame 来处理视频（加滤镜等操作）

```javascript
requestAnimationFrame(function () {
  //画
  gd.drawImage(oV, 0, 0); //将视频画上

  //取
  let imageData = gd.getImageData(0, 0, oC.width, oC.height); //取该一帧的画面

  for (let r = 0; r < oC.height; r++) {
    for (let c = 0; c < oC.width; c++) {
      //双循环来获取每个画面的像素点
      let color =
        (imageData.data[(r * oC.width + c) * 4] +
          imageData.data[(r * oC.width + c) * 4 + 1] +
          imageData.data[(r * oC.width + c) * 4 + 2]) /
        3;

      imageData.data[(r * oC.width + c) * 4] =
        imageData.data[(r * oC.width + c) * 4 + 1] =
        imageData.data[(r * oC.width + c) * 4 + 2] =
          color; //将每个像素点的颜色都进行处理
    }
  }
  gd.putImageData(imageData, 0, 0); //将更改后的像素点重画上
});
```

### 2.7.3 使用 canvas 画图传至服务端

```javascript
let gd = oC.getContext("2d");
let str = oC.toDataURL(); //1.将画好的图片转成base64字符串
//2.发给服务器
let xhr = new XMLHttpRequest();
xhr.open("post", "/upload_base64", true);
xhr.send(encodeURIComponent(str)); //base64位需编码
xhr.onreadystatechange = function () {
  if (xhr.readyState == 4) {
    alert(xhr.status);
  }
};
```

### 2.7.4 将 input 获取的文件画在页面上

```javascript
let reader = new FileReader();
reader.onload = function () {
  let oImg = new Image();
  oImg.src = this.result;
  oImg.onload = function () {
    gd.drawImage(oImg, 0, 0);
  };
  reader.readAsDataURL(oF.files[0]);
};
```

## 2.8 拖拽文件上传

```javascript
oBox.addEventListener(
  "drop",
  function (ev) {
    ev.preventDefault();
    //
    let formData = new FormData();
    Array.from(ev.dataTransfer.files).forEach((file) => {
      formData.append("f1", file);
    });

    //ajax
    let xhr = new XMLHttpRequest();
    xhr.upload.onprogress = function (ev) {
      oM.value = Math.floor((100 * ev.loaded) / ev.total);
    };
    xhr.upload.onload = function () {
      alert("上传完成");
    };

    xhr.open("post", "/upload", true);
    xhr.send(formData);

    //服务器返回
    xhr.onreadystatechange = function () {
      if (xhr.readyState == 4) {
        alert(xhr.status);
      }
    };
  },
  false
);
```

### 2.7.6 ajax 上传文件等内容方法

ajax 一切操作都是在模拟表单，一般使用 FormData 对象来构建表单

```js
oAjax.send(formData); //ajax发送FormData
formData.set(名字, 值); //form提供的方法，值可为file
formData.append(名字, 值); //form提供的方法，值可为file,append可增加多个文件
```

#### 2.6.6.1 上传进度实现

| onabort                            | 终止     |
| ---------------------------------- | -------- |
| onerror                            | 错误     |
| onload                             | 完成     |
| onloadstart                        | 开始     |
| onloadend                          | 结束     |
| onprogress(**ev.loaded/ev.total**) | 进度变化 |
| ontimeout                          | 超时     |

```javascript
    let oAjax=new XMLHttpRequest();
    //进度
    oAjax.upload.onerror=function (){   // upload方法要放在open方法前
        alert('上传出错，请稍候重试');
    };
    oAjax.upload.onload=function (){
        alert('上传完成');
    };
    oAjax.upload.onprogress=function (ev){ // ev.loaded/ev.total可以获取到进度
        let str=(100*ev.loaded/ev.total).toFixed(2)+'%';
        let oChild=document.querySelector('.child');
        oChild.style.width=str;
    };

    oAjax.open('POST', '/upload', true);

    //表单
    let formData=new FormData();
    aFile.forEach(oFile=>{
        Array.from(oFile.files).forEach(file=>{
            formData.append('f1', file);
        });
    });

    oAjax.send(formData);

    oAjax.onreadystatechange=function (){
        if(oAjax.readyState==4){
            alert(oAjax.status);
        }
```

#### 2.6.6.2 上传图片或文件时 node 的处理

```javascript
//读取文件 readFile(文件名, [编码,] cb)
const fs = require("fs");
fs.readFile("1.gif", "base64", (err, data) => {
  if (err) {
    console.log("读取失败");
  } else {
    console.log(data);
  }
});
//写入文件writeFile(文件名, 东西, [编码,] cb)
```

```javascript
//使用POST请求获取base64位格式的图片   GET	1个包   POST	n个包  post数据必须分很多次接收
const http = require("http");
let server = http.createServer((req, res) => {
  //注意：下面的post接收方式有瑕疵
  let str = "";
  req.on("data", (data) => {
    str += data;
  });
  req.on("end", () => {
    console.log("post数据接收完了", str);
  });
});
server.listen(8080);
```

```javascript
//一个完整的POST请求
const http = require("http");
const fs = require("fs");
const url = require("url");
const uuidv4 = require("uuid/v4");

let server = http.createServer((req, res) => {
  const { pathname, query } = url.parse(req.url, true);
  if (pathname == "/upload_base64") {
    //3.接收字符串
    let str = ""; //问题不大——以后再改
    req.on("data", (data) => {
      str += data;
    });
    req.on("end", () => {
      str = decodeURIComponent(str);
      str = str.replace(/data:[a-z\-]+(\/[a-z\-]+)?;base64,/i, "");
      //4.保存下来
      fs.writeFile(
        `./www/upload/${uuidv4().replace(/\-/g, "")}`,
        str,
        "base64",
        (err) => {
          if (err) {
            res.writeHeader(500);
            res.write("write file error");
          } else {
            res.write("ok");
          }
          res.end();
        }
      );
    });
  } else {
    fs.readFile(`./www${pathname}`, (err, data) => {
      if (err) {
        res.writeHeader(404);
        res.write("not found");
      } else {
        res.write(data);
      }
      res.end();
    });
  }
});
server.listen(8080);
```

### 2.6.7 requestAnimationFrame()

```javascript
requestAnimationFrame(function () {
  //向浏览器请求一帧，传递一个回调函数循环执行
  gd.drawImage(oV, 0, 0); //每隔一帧执行一次该操作
});
```

## 2.9 SVG 相关操作

### 2.9.1 SVG 相关操作方法

- stroke: #70d5dd; fill: #dd524b ; stroke-width="1" 可写在 style 中，也可直接以属性写在标签中

- svg 的样式两种写法： 1.属性形式
  2.style 形式 推荐以行内样式写上，因为其优先级最低

- SVG 图形： 1.样式操作 跟 HTML 一样(推荐用 style) 2.事件操作 跟 HTML 一样(完全一样) 3.属性操作 有点区别(set/get)
  HTML SVG
  设置 .xxx=xxx .setAttribute
  .setAttribute
  获取 .xxx .getAttribute
  .getAttribute

- DOM 操作
  获取 完全一样
  创建 HTML: createElement
  SVG: createElementNS('http://www.w3.org/2000/svg')
  插入 完全一样

- 图形
  1.rect 矩形 x,y,width,height,rx,ry
  2.circle 正圆 cx,cy,r
  3.ellipse 椭圆 cx,cy,rx,ry
  4.line 直线 x1,y1,x2,y2 5.多边形

  6.path(路径)
  M x,y
  L (x,y)+
  Z
  A rx ry x-axis-rotation large-arc-flag sweep-flag x y
  x 半径 y 半径 x 轴旋转 大弧标志(0,1) 镜像标志 终点 x y

  注意：如果没有背景色(fill:none)，会导致背景没有事件——用透明

### 2.9.2 SVG 画相关图形

```javascript
<!-- 画圆 -->
<svg width="300" height="180">
    <circle cx="30" cy="50" r="25" />
    <circle cx="90" cy="50" r="25" class="red" />
    <circle cx="150" cy="50" r="25" class="fancy" />
</svg>

<!-- 直线 -->
<svg width="300" height="180">
    <line x1="0" y1="0" x2="200" y2="0" style="stroke:rgb(0,0,0);stroke-width:5" />
</svg>

<!-- 折线 -->
<svg width="300" height="180">
    <polyline points="3,3 30,28 3,53" fill="none" stroke="black" />
</svg>

<!-- 矩形 -->
<svg width="300" height="180">
    <rect x="0" y="0" height="100" width="200" style="stroke: #70d5dd; fill: #dd524b" />
</svg>

<!-- 椭圆 -->
<svg width="300" height="180">
    <ellipse cx="60" cy="60" ry="40" rx="20" stroke="black" stroke-width="5" fill="silver" />
</svg>

<!-- 多边形 -->
<svg width="300" height="180">
    <polygon fill="green" stroke="orange" stroke-width="1" points="0,0 100,0 100,100 0,100 0,0" />
</svg>

<!-- 路径 -->
<svg width="300" height="180">
    <path d="
             M 18,3
             L 46,3
             L 46,40
             L 61,40
             L 32,68
             L 3,40
             L 18,40
             Z
             ">
    </path>
</svg>

<!-- 文本 -->
<svg width="300" height="180">
    <text x="50" y="25" style="stroke: #70d5dd; fill: #dd524b">Hello World</text>
</svg>

<!-- 复制形状 -->
<svg viewBox="0 0 30 10" xmlns="http://www.w3.org/2000/svg">
    <circle id="myCircle" cx="5" cy="5" r="4" />
    <use href="#myCircle" x="10" y="0" fill="blue" />
    <use href="#myCircle" x="20" y="0" fill="white" stroke="blue" />
</svg>

<!-- 多个形状组成一个组 -->
<svg width="300" height="100">
    <g id="myCircle">
        <text x="25" y="20">圆形</text>
        <circle cx="50" cy="50" r="20" />
    </g>
    <use href="#myCircle" x="100" y="0" fill="blue" />
    <use href="#myCircle" x="200" y="0" fill="white" stroke="blue" />
</svg>

<!-- 自定义形状，它内部的代码不会显示 -->
<svg width="300" height="100">
    <defs>
        <g id="myCircle">
            <text x="25" y="20">圆形</text>
            <circle cx="50" cy="50" r="20" />
        </g>
    </defs>
    <use href="#myCircle" x="0" y="0" />
    <use href="#myCircle" x="100" y="0" fill="blue" />
    <use href="#myCircle" x="200" y="0" fill="white" stroke="blue" />
</svg>

<!-- <pattern>标签用于自定义一个形状 -->
<svg width="500" height="500">
    <defs>
        <pattern id="dots" x="0" y="0" width="100" height="100"
                 patternUnits="userSpaceOnUse">
            <circle fill="#bee9e8" cx="50" cy="50" r="35" />
        </pattern>
    </defs>
    <rect x="0" y="0" width="100%" height="100%" fill="url(#dots)" />
</svg>

<!-- <animate>标签用于产生动画效果。 -->
<svg width="500px" height="100px">
    <rect x="0" y="0" width="100" height="100" fill="#feac5e">
        <animate attributeName="x" from="0" to="500" dur="2s" repeatCount="indefinite" />
        <animate attributeName="width" to="500" dur="2s" repeatCount="indefinite" />
    </rect>
</svg>

<!-- <animateTransform>标签 -->
<svg width="500px" height="500px">
    <rect x="250" y="250" width="50" height="50" fill="#4bc0c8">
        <animateTransform attributeName="transform" type="rotate" begin="0s" dur="10s" 				from="0 200 200" to="360 400 400" repeatCount="indefinite" />
    </rect>
</svg>
```

## 2.10 Raphael.js 使用

能兼容 VML 和 SVG，并且有扩展功能——动画

```javascript
//1.创建画布
let paper = Raphael(x, y, width, height);

//2.创建形状
let rect = paper.rect(x, y, width, height);
let path = paper.path("M 100 100 L 400 100 400 300 100 300 Z");

//3.设置属性(样式)
rect.attr({ fill: "red", stroke: "green" }); //填充样式
path.attr("stroke-width", 20); //边线样式
path.attr("stroke-linejoin", "miter");
path.attr("stroke-miterlimit", "5");
path.attr("stroke-dasharray", "--..");

//4.事件
path.hover(
  function () {
    this.attr("fill", "green");
  },
  function () {
    this.attr("fill", "yellow");
  }
);

//5.过渡
rect.click(function () {
  //this.attr('transform', 's2,1 r30');
  // x轴放大两倍，Y轴放大一倍，旋转30度
  this.animate({ transform: "s2,1 r30" }, 1000, "linear");
});

//6.动画
// 'linear', 'easeIn', 'easeOut', 'easeInOut', 'backIn', 'backOut', 'elastic', 'bounce'
rect.animate({ x: 600 }, 3000, "linear"); //位置动画
rect.animate({ fill: "green" }, 2000); //填充动画
rect.animate({ "stroke-width": "20" }, 2000); //描边动画
rect.animate({ path: "M 100 100 L 400 100 400 300 100 300 Z" }, 700, "bounce"); //路径
```

### 2.10.1 形状

| 名称    | 参数                     | 说明 |
| ------- | ------------------------ | ---- |
| rect    | x, y, width, height, [r] | 矩形 |
| circle  | cx, cy, r                | 圆   |
| ellipse | cx, cy, rx, ry           | 椭圆 |
| image   | src, x, y, width, height | 图片 |
| path    | pathString               | 路径 |
| text    | x, y, text               | 文字 |

### 2.10.2 事件

| 名称                    | 说明       |
| ----------------------- | ---------- |
| click/unclick           | 点击       |
| dblclick/undblclick     | 双击       |
| hover/hover             | 移入、移出 |
| mousedown/unmousedown   | 鼠标按下   |
| mousemove/unmousemove   | 鼠标移动   |
| mouseup/unmouseup       | 鼠标抬起   |
| touchstart/untouchstart | 手指按下   |
| touchmove/untouchmove   | 手指移动   |
| touchend/untouchend     | 手指抬起   |

### 2.10.3 transform

transform 以字符串形式写，例如：`"t200,50r45s2"`

| 命令 | 说明      | 参数  |
| ---- | --------- | ----- |
| t    | translate | x,y   |
| r    | rotate    | angle |
| s    | scale     | x,y   |

### 2.10.4 路径

| 命令 | 说明                                                 | 参数                                                   |
| ---- | ---------------------------------------------------- | ------------------------------------------------------ |
| M    | moveto                                               | (x y)+                                                 |
| Z    | 闭合                                                 |                                                        |
| L    | lineto                                               | (x y)+                                                 |
| H    | 横线(horizontal)                                     | x+                                                     |
| V    | 竖线(vertical)                                       | y+                                                     |
| C    | 曲线(curve)                                          | (x1 y1 x2 y2 x y)+                                     |
| S    | 平滑曲线(smooth)                                     | (x2 y2 x y)+                                           |
| Q    | 二次贝赛尔曲线(quadratic)                            | (x1 y1 x y)+                                           |
| T    | 平滑二次贝塞尔曲线                                   | (x y)+                                                 |
| A    | 弧线(arc)                                            | (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+ |
| R    | 卡特莫尔罗曲线(CatmullRom)——抗锯齿平滑曲线的一种算法 | x1 y1 (x y)+                                           |

### 2.10.5 属性

| 名称              | 类型     | 说明                                                                                                                                                                                    |
| ----------------- | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| x                 | `number` |                                                                                                                                                                                         |
| y                 | `number` |                                                                                                                                                                                         |
| width             | `number` |                                                                                                                                                                                         |
| height            | `height` |                                                                                                                                                                                         |
| rx                | `number` | 圆角 x                                                                                                                                                                                  |
| ry                | `number` | 圆角 y                                                                                                                                                                                  |
| cx                | `number` | 圆心 x                                                                                                                                                                                  |
| cy                | `number` | 圆心 y                                                                                                                                                                                  |
| r                 | `number` | 半径                                                                                                                                                                                    |
| opacity           | `number` | 透明度                                                                                                                                                                                  |
| path              | `string` | path 字符串                                                                                                                                                                             |
| src               | `string` | 图片地址，只有 image 元素可用                                                                                                                                                           |
| transform         | `string` | 类似 transform()方法                                                                                                                                                                    |
| **边线样式**      |          |                                                                                                                                                                                         |
| stroke            | `string` | 边线，只能是颜色                                                                                                                                                                        |
| stroke-width      | `number` | 边线宽度                                                                                                                                                                                |
| stroke-linecap    | `string` | 端点形状：[“butt”, “square”, “round”]                                                                                                                                                   |
| stroke-linejoin   | `string` | 接头形状：[“bevel”, “round”, “miter”]                                                                                                                                                   |
| stroke-dasharray  | `string` | 边线虚线，-和.组成："-.-"/"-"/"--..\_..--"                                                                                                                                              |
| stroke-miterlimit | `number` | 斜接长度限制，只有当接头是 miter 时有效                                                                                                                                                 |
| stroke-opacity    | `number` | 边线透明度                                                                                                                                                                              |
| **填充样式**      |          |                                                                                                                                                                                         |
| fill              | `number` | 填充，可以是颜色、渐变或图片                                                                                                                                                            |
| fill-opacity      | `number` | 填充透明度                                                                                                                                                                              |
| **字体**          |          |                                                                                                                                                                                         |
| font              | `string` | 类似于 css 的 font                                                                                                                                                                      |
| font-family       | `string` | 字体                                                                                                                                                                                    |
| font-size         | `number` | 字体大小                                                                                                                                                                                |
| font-weight       | `string` | 加粗                                                                                                                                                                                    |
| text              | `string` | text 元素的文字内容                                                                                                                                                                     |
| text-anchor       | `string` | 文本对齐：[“start”, “middle”, “end”]                                                                                                                                                    |
| title             | `string` | text 的 tooltip                                                                                                                                                                         |
| href              | `string` | 链接地址                                                                                                                                                                                |
| target            | `string` | 链接 target                                                                                                                                                                             |
| **其他**          |          |                                                                                                                                                                                         |
| cursor            | `string` | 鼠标指针，类似于 css 的 cursor 样式                                                                                                                                                     |
| arrow-end         | `string` | arrowhead on the end of the path. The format for string is [-[-]]. Possible types: classic, block, open, oval, diamond, none, width: wide, narrow, midium, length: long, short, midium. |
| clip-rect         | `string` | comma or space separated values: x, y, width and height                                                                                                                                 |

## 2.11 echarts 使用

### 2.11.1 使用步骤

```javascript
let box = document.querySelector('.box')
let charts=echarts.init(box)
let option={
    title:      //标题
    xAxis:      //柱状图x轴
    yAxis:      //柱状图y轴
    legend: {   //指示器
          data: ['男', '女'],
          right: 0,
          top: '50%',
          orient: 'vertical'
        },
    series:[    数据
        {
        name: '名字',
        type: 'bar/pie/radar',   //图形类型
        data: [数据]
       }
	]
};
charts.setOption(option);   //设置选项
charts.on('mouseover', function (ev){  //事件
     console.log(v.name)
 });
```

### 2.11.2 典型的柱状图

```javascript
let oBox=$('.box')[0];
let option={
    title: {
        text: '北京人口数量',
        subtext: '2017年(单位：万)'
    },
    legend: {
        data: ['男', '女'],
        right: 0,
        top: '50%',
        orient: 'vertical'
    },
    xAxis: [
        {
            type: 'category',
            data: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月',
                   '11月', '12月']
        }
    ],
    yAxis: [
        {
            type: 'value'
        }
    ],
    series: [
        {
            name: '男',
            type: 'bar',
            data: [1352, 23, 1354, 1354, 1355, 1356, 1364, 1454, 1334, 1254, 1350, 754]
        },
        {
            name: '女',
            type: 'bar',
            data: [1245, 12, 1254, 1254, 1255, 1256, 1464, 1354, 1234, 1154, 1250, 454]
        }
    ],
    animationEasing: 'bounceOut',
    animationDelayUpdate(index){
        return index*700
 }
```

### 2.11.3 典型饼图

```js
let oBox = document.querySelector(".box");
let option = {
  title: {
    text: "北京人口数量",
    subtext: "2017年(单位：万)",
  },
  series: [
    //数组，可传多对象，生成几个饼
    {
      name: "学历比例",
      type: "pie",
      radius: "20%", //饼图半径
      center: ["30%", "50%"],
      data: [
        { name: "小学", value: 350 },
        { name: "中学", value: 120 },
        { name: "大学", value: 1524 },
        { name: "研究生", value: 410 },
        { name: "博士及以上", value: 85 },
      ],
    },
    {
      name: "性别比例",
      type: "pie",
      //radius: '60%',
      radius: ["70%", "80%"],
      center: ["70%", "50%"],
      data: [
        { name: "男", value: 2752 },
        { name: "女", value: 1985 },
        { name: "其他", value: 3 },
      ],
    },
  ],
};
let charts = echarts.init(oBox);
charts.setOption(option);
```

### 2.11.4 雷达图

```js
let option = {
  title: {
    text: "北京人口数量",
    subtext: "2017年(单位：万)",
  },
  legend: {
    data: ["角色", "敌人"],
    right: 0,
    top: "50%",
    orient: "vertical",
  },
  radar: {
    //雷达图传用配置
    indicator: [
      { name: "HP", max: 9999 },
      { name: "攻击", max: 99 },
      { name: "防御", max: 99 },
      { name: "魔法", max: 99 },
    ],
  },
  series: [
    {
      name: "属性",
      type: "radar",
      data: [
        {
          name: "角色",
          value: [1570, 23, 65, 17],
        },
        {
          name: "敌人",
          value: [2300, 89, 76, 65],
        },
      ],
    },
  ],
};
let charts = echarts.init(oBox);
charts.setOption(option);
```

## 2.12 D3 使用

D3 可以分着用、也能合着用，主要有以下特性

| --          | --       |
| ----------- | -------- |
| Arrays      | 数组     |
| Colors      | 颜色     |
| Collections | 数据结构 |
| Forces      | 物理计算 |
| Scales+Axes |          |

> d3 的核心
>
> ---
>
> 1.访问器——抽出特征 2.生成器——批量处理数据(高性能)
>
> ---
>
> d3 也能做 dom 操作
> d3.select('父级').append('标签').attr().style()
>
> ---
>
> d3——计算库
>
> 图表：
> 数据->计算=>{角度...}=>计算=>{点坐标, 点 2 坐标, ...}->生成 path

### 2.12.1 D3 提供的数组及颜色等方法

```js
//数组相关操作
d3.max([12, 5, 8, 99, 27]); //数组最大值
d3.extent([12, 5, 8, 99, 27]); //数组最大值和最小值
```

```js
//颜色相关操作,均可获取rgb值
console.log(d3.color("red"));
console.log(d3.color("#f00"));
console.log(d3.color("rgb(255,0,0)"));
console.log(d3.color("rgba(255,0,0,0.3)"));
console.log(d3.color("rgba(50%,30%,30%,0.3)"));
console.log(d3.color("rgba(50%,0%,30%,0.3)"));
```

```js
//map和set相关操作
let map = d3.map(
  [
    { name: "blue", age: 18 },
    { name: "alex", age: 25 },
    { name: "tom", age: 27 },
  ],
  (item) => item.age
);
console.log(map.get(25));

let set = d3.set(
  [
    { name: "blue", age: 18 },
    { name: "alex", age: 25 },
    { name: "tom", age: 27 },
  ],
  (item) => item.age
);
console.log(set.has("blue"));
```

```js
//数字格式化生成器
let gen = d3.format("10.3f");
console.log(gen(128.555555)); //生成器处理数据

//日期格式化生成器
let gen = d3.timeFormat("%Y年%m月%d日 %H:%M:%S");
console.log(gen(Date.now())); //生成器处理时间
```

```js
//随机数
let gen = d3.randomUniform(5, 20); //均值分布
let gen = d3.randomNormal(15); //正态分布(高斯分布)
```

```js
//D3做DOM操作
d3.select("body")
  .append("div")
  .style("width", "300px")
  .style("height", "200px")
  .style("background", "red");

//D3操作SVG
d3.select("body")
  .append("svg")
  .attr("width", 800)
  .attr("height", 600)
  .append("path")
  .attr("d", "M 100,100 L 300,200 200,100")
  .attr("stroke", "black")
  .attr("fill", "none");
```

### 2.12.3 绘制折线图

```js
let datas = [
  //数据
  { name: "1月", value: 1750 },
  { name: "2月", value: 541 },
  { name: "3月", value: 875 },
  { name: "4月", value: 3752 },
  { name: "5月", value: 548 },
  { name: "6月", value: 987 },
];

//1.计算——点坐标...
let lineGen = d3
  .line() //1.1.创建生成器
  .x((item) => (parseInt(item.name) - 1) * (10 + 780 / (datas.length - 1)))
  .y((item) => 500 - item.value / 10);

let res = lineGen(datas); //1.2.拿着生成器计算东西
console.log(res); //获取每个点的坐标

//2.创建图形来显示数据
d3.select("body")
  .append("svg")
  .attr("width", 800)
  .attr("height", 600)
  .style("border", "1px solid black")
  .append("path")
  .attr("d", res)
  .attr("stroke", "black")
  .attr("fill", "none");
```

### 2.12.4 绘制饼图

```js
let datas = [
  { name: "不及格", value: 68 },
  { name: "及格", value: 276 },
  { name: "优秀", value: 53 },
  { name: "满分", value: 23 },
];

let svg = d3
  .select("body")
  .append("svg")
  .attr("width", 800)
  .attr("height", 600)
  .style("border", "1px solid black");
let g = svg.append("g");
let paths = [];

//1.计算
let pie = d3
  .pie()
  .value((item) => item.value)
  .padAngle((3 * Math.PI) / 180); //1.1.计算每一个pie的角度
let pieRes = pie(datas);
console.log(pieRes);

let arc = d3.arc().innerRadius(130).outerRadius(150); //1.2.计算每一个点的坐标
let rnd = d3.randomUniform(0, 100);

pieRes.forEach((pieData) => {
  let arcRes = arc(pieData);
  console.log(arcRes);

  //2.生成
  let path = g
    .append("path")
    .attr("d", arcRes)
    .attr("stroke", "none")
    .attr("fill", d3.color(`rgb(${rnd()}%,${rnd()}%,${rnd()}%)`));
  paths.push(path);
});

//整组一起移动
g.attr("transform", "translate(400, 300) rotate(30)");

//paths
let oBtn = document.getElementById("btn1");
oBtn.onclick = function () {
  paths[0].remove();
  //paths[0].attr('fill', 'yellow');
  datas.splice(0, 1);
};
```

## 2.13 vscode 自增符号：$

https://segmentfault.com/a/1190000018615760

**ul>li\*10{$个 li}** 可以快速生成 10 个 li 并按顺序排列

- ul>li.list\_${list $}\*3

```
<ul>
    <li class="list_1">list 1</li>
    <li class="list_2">list 2</li>
    <li class="list_3">list 3</li>
</ul>
```

- ul>li.item$@3\*3 “@3” 表示从 3 开始计数

```
<ul>
    <li class="item3">list 1</li>
    <li class="item4">list 2</li>
    <li class="item5">list 3</li>
</ul>
```

## 2.14 前端二进制

`Blob、Blob URL、Base64、Data URL、ArrayBuffer、TypedArray、DataView 和图片压缩`等

```js
// buffer不能直接操作
const buffer = new ArrayBuffer(8)
// 可通过TypedArray操作
const uint8Array = new Uint8Array(buffer)
uint8Array[0] = 126
// 或通过DataView 操作
const dataView = new DataView(buffer)
dataView.setInt8(0,125)
dataView.getInt8(0,125)

const blob = new Blob([buffer], { type: 'text/plan' })
const fileReader = new FileReader()
fileReader.readAsText(blob)
fileReader.onload = function (e) {
    console.log(e.target.result); //打印结果是文件的ASCII
}
```



 [jsPDF](https://github.com/MrRio/jsPDF)PDF相关功能库、

 [sheetjs](https://github.com/SheetJS/sheetjs)表格处理库、

 [FileSaver.js](https://github.com/eligrey/FileSaver.js/)处理文件保存功能、

[file-type](https://github.com/sindresorhus/file-type#readme)不根据后缀名获取文件类型、

[Mammoth.js](https://github.com/mwilliamson/mammoth.js) 转换 .docx 文档（例如由 Microsoft Word 创建的文档），并将其转换为 HTML

[JSZip](https://stuk.github.io/jszip/) 是一个用于创建、读取和编辑 **「.zip」** 文件的 JavaScript 库

[FileSaver.js](https://github.com/eligrey/FileSaver.js) 在客户端保存文件

[docx](https://github.com/dolanmiu/docx) 或 [html-docx-js](https://github.com/evidenceprime/html-docx-js) 前端动态生成 Word 文档

```js
// docx生成文档
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title></title>
  </head>
  <body>
    <h1>动态生成 Word 文档示例</h1>

    <button type="button" onclick="generate()">
      点击生成 Docx 文档
    </button>
    <script src="https://unpkg.com/docx@5.0.2/build/index.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/1.3.8/FileSaver.js"></script>
    <script>
      async function generate() {
        const doc = new docx.Document();

        const imageBuffer = await fetch(
          "https://avatars3.githubusercontent.com/u/4220799"
        ).then((response) => response.arrayBuffer());

        const image = docx.Media.addImage(doc, imageBuffer, 230, 230);

        doc.addSection({
          properties: {},
          children: [
            new docx.Paragraph({
              children: [
                new docx.TextRun({
                  text: "全栈修仙之路，",
                  bold: true,
                }),
                new docx.TextRun({
                  text:
                    "聚焦全栈，专注分享 TypeScript、Web API、Node.js、Deno 等全栈干货。",
                }),
              ],
            }),
            new docx.Paragraph(image),
          ],
        });

        docx.Packer.toBlob(doc).then((blob) => {
          console.log(blob);
          saveAs(blob, "abao.docx");
          console.log("文档生成成功");
        });
      }
    </script>
  </body>
</html>
```

