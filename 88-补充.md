```js
vscode常用插件：code runner(选中代码片段执行)  code spell Checker(单词拼写检查)  
			  bracket Pair Colorizer(美化代码片段)
```



#  一、 javaScript高级程序设计

## 1.1 获取当前获得了焦点的元素

```javascript
document.activeElement    
document.hasFocus()      // 获取当前元素是否获取了焦点
```

## 1.2 insertAdjacentHTML()方法 

注意，这些值都必须是小写形式。第二个参数是一个 HTML 字符串（与 innerHTML 和 outerHTML
的值相同），如果浏览器无法解析该字符串，就会抛出错误。以下是这个方法的基本用法示例。

```javascript
 "beforebegin" ，在当前元素之前插入一个紧邻的同辈元素；
 "afterbegin"  ，在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素；
 "beforeend"   ，在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素；
 "afterend"    ，在当前元素之后插入一个紧邻的同辈元素。

//作为前一个同辈元素插入
element.insertAdjacentHTML("beforebegin", "<p>Hello world!</p>");
//作为第一个子元素插入
element.insertAdjacentHTML("afterbegin", "<p>Hello world!</p>");
//作为最后一个子元素插入
element.insertAdjacentHTML("beforeend", "<p>Hello world!</p>");
//作为后一个同辈元素插入
element.insertAdjacentHTML("afterend", "<p>Hello world!</p>")
```

## 1.3 scrollIntoView()方法的使用

注：凡是需要滚动的地方都加一句scroll-behavior:smooth就好

```js
如：html, body { scroll-behavior:smooth; }
```

```js
element.scrollIntoView(); // 等同于element.scrollIntoView(true) 
element.scrollIntoView(alignToTop); // Boolean型参数 
element.scrollIntoView(scrollIntoViewOptions); // Object型参数

// 语法
var element = document.getElementById("box");
element.scrollIntoView();
element.scrollIntoView(false);
element.scrollIntoView({block: "end"});
element.scrollIntoView({behavior: "instant", block: "end", inline: "nearest"});

behavior 可选   定义缓动动画， "auto", "instant", 或 "smooth" 之一。默认为 "auto"。
block 可选	  "start", "center", "end", 或 "nearest"之一。默认为 "start"。
inline 可选     "start", "center", "end", 或 "nearest"之一。默认为 "nearest"。
```

## 1.4 触发其它元素的事件

注：初始化事件对象可简写至 `event.initEvent("click", true, true);　`

```js
//触发btn的点击事件
var btn = document.getElementById("myBtn");
//创建事件对象
var event = document.createEvent("MouseEvents");
//初始化事件对象 
event.initMouseEvent("click", true, true, document.defaultView, 0, 0, 0, 0, 0,
false, false, false, false, 0, null);
//触发事件
btn.dispatchEvent(event);

//触发textbox的键盘事件
var textbox = document.getElementById("myTextbox")
//以 DOM3 级方式创建事件对象
event = document.createEvent("KeyboardEvent");
//初始化事件对象
event.initKeyboardEvent("keydown", true, true, document.defaultView, "a",0, "Shift", 0);
//触发事件
textbox.dispatchEvent(event);
```

## 1.5 操作剪切版

```js
6 个剪贴板事件。
 beforecopy ：在发生复制操作前触发。
 copy ：在发生复制操作时触发。
 beforecut ：在发生剪切操作前触发。
 cut ：在发生剪切操作时触发。
 beforepaste ：在发生粘贴操作前触发。
 paste ：在发生粘贴操作时触发。
```

## 1.6 操作富文本

主要使用 **` document.execCommand()`**。3 个参数：命令名称、false、值

| 命令          | 值（第三个参数） | 说明                           |
| ------------- | ---------------- | ------------------------------ |
| backcolor     | 颜色字符串       | 设置文档的背景颜色             |
| bold          | null             | 将选择的文本转换为粗体         |
| copy          | null             | 将选择的文本复制到剪贴板       |
| createlink    | URL字符串        | 将选择的文本转换成一个链接     |
| cut           | null             | 将选择的文本剪切到剪贴板       |
| delete        | null             | 删除选择的文本                 |
| fontname      | 字体名称         | 将选择的文本修改为指定字体     |
| fontsize      | 1～7             | 将选择的文本修改为指定字体大小 |
| forecolor     | 颜色字符串       | 将选择的文本修改为指定的颜色   |
| italic        | null             | 将选择的文本转换成斜体         |
| justifycenter | null             | 将插入光标所在文本块居中对齐   |
| justifyleft   | null             | 将插入光标所在文本块左对齐     |
| underline     | null             | 为选择的文本添加下划线         |

```js
//转换粗体文本
document.execCommand("bold", false, null);
//转换斜体文本
document.execCommand("italic", false, null);
//创建指向 www.wrox.com 的链接
document.execCommand("createlink", false, "http://www.wrox.com");
//格式化为 1 级标题
document.execCommand("formatblock", false, "<h1>");
```

样关方法：

```js
//检测命令是否可以针对当前选择的文本
var result = 元素.document.queryCommandEnabled("bold")  //返回值为true或false
//是否已将指定命令应用到了选择的文本
var isBold = 元素.document.queryCommandState("bold")  //返回值为true或false
//取得执行命令时传入的值
var fontSize = 元素.document.queryCommandValue("fontsize") //返回执行命令时传入的值
```

富文本选区

```js
var selection = frames["richedit"].getSelection(); //获取选区
var selectedText = selection.toString(); //取得选择的文本
var range = selection.getRangeAt(0);//取得代表选区的范围
var span = frames["richedit"].document.createElement("span");//突出显示选择的文本
span.style.backgroundColor = "yellow";
range.surroundContents(span); //将选区添加到了带有黄色背景的 <span> 元素中
```

## 1.7 防篡改对象

### 1.7.1 不可扩展对象

不能再给对象添加属性和方法

```js
var person = { name: "Nicholas" };
Object.preventExtensions(person);   //不能再给对象添加属性和方法
person.age = 29;
alert(person.age); //undefined
Object.istExtensible(person)   //确定对象是否可以扩展
```

### 1.7.2 密封的对象

密封对象不可扩展，而且已有成员的 [[Configurable]] 特性将被设置为 false 。这就意味着不能删除属性和方法

```js
var person = { name: "Nicholas" };
Object.seal(person);   //密封对象
person.age = 29;
alert(person.age); //undefined
delete person.name;
alert(person.name); //"Nicholas"
Object.isSealed(person) //确定对象是否被密封
```

### 1.7.3 冻结的对象

最严格的防篡改级别是冻结对象（frozen object）。冻结的对象既不可扩展，又是密封的，而且对象数据属性的 [[Writable]] 特性会被设置为 false

```js
var person = { name: "Nicholas" };
Object.freeze(person); //冻洁对象
person.age = 29;
alert(person.age); //undefined
delete person.name;
alert(person.name); //"Nicholas"
person.name = "Greg";
alert(person.name); //"Nicholas"
Object.isFrozen(person) //确定对象是否被冻洁
```

## 1.8 Page Visibility API

```js
 document.hidden ：表示页面是否隐藏的布尔值。页面隐藏包括页面在后台标签页中或者浏览器最小化。
 document.visibilityState ：表示下列 4 个可能状态的值。
  *页面在后台标签页中或浏览器最小化。
  *页面在前台标签页中。
  *实际的页面已经隐藏，但用户可以看到页面的预览（就像在 Windows 7 中，用户把鼠标移动到任务栏的图标上，就	  可以显示浏览器中当前页面的预览）。
  *页面在屏幕外执行预渲染处理。
 visibilitychange 事件：当文档从可见变为不可见或从不可见变为可见时，触发该事件。
```

## 1.9 JSONP实现跨域请求

```javascript
function jsonp({ url, params, callback }) {   //定义
    return new Promise((resolve, reject) => {
        let script = document.createElement('script');
        window[callback] = function (data) {
            resolve(data)
            document.body.removeChild(script)
        }
        script.onerror=function(error){ 
            reject(data)
            document.body.removeChild(script) }
        params = { ...params, callback } // wd=b&callback=show
        let arrs = []
        for (let key in params) {
            arrs.push(`${key}=${params[key]}`)
        }
        script.src = `${url}?${arrs.join('&')}`
        document.body.appendChild(script)
    })}
jsonp({    // 调用
    url: 'http://localhost:3000/',
    params: { wd: 'Iloveyou' },
    callback: 'show'
}).then(data => {
    console.log(data)
}).catch(error=>{
    console.log(error)
})


// server.js
let express = require('express')
let app = express()
app.get('/', function(req, res) {
  let { wd, callback } = req.query
  console.log(wd) // Iloveyou
  console.log(callback) // show
  res.end(`${callback}('哈哈哈')`)
})
app.listen(3000,function(){
    console.log('app run port 3000')
})
```

## 2.0 URLSearchParams 使用方法

> * 处理URL的query：

```javascript
let url = '?name=蔡&skill=篮球&year=2019';
let searchParams = new URLSearchParams(url);
for (let p of searchParams) {
    console.log(p);
 }// ["wd", "蔡徐坤"]  // ["skill", "篮球"]  // ["year", "2019"]
searchParams.get('wd')    // "蔡"
searchParams.get('skill') // "篮球"
searchParams.get('year')  // "2019"
searchParams.has('wd') // true
searchParams.has('age') // false
searchParams.append('age', 26)
searchParams.has('age') // true
searchParams.get('age') // 26
searchParams.delete('year')
searchParams.has('year') // false
searchParams.set('skill', '篮球 唱 跳 rap');
searchParams.toString()
// "wd=蔡&skill=篮球+唱+跳+rap&year=2019&age=26"
```

## 2.1  **伪类与伪元素的区别**

* 伪类：更多的定义的是状态。常见的伪类有 :hover，:active，:focus，:visited，:link，:not，:firstchild，:last-child等等。
* 伪元素：不存在DOM树中的虚拟元素，它们可以像正常的html元素一样定义css，无法使用JavaScript获取。常见伪元素有 ::before，::after，::first-letter，::first-line等等。

```html
<div class="t-collapse">
    <a class="collapse-target" href="#modal1">target 1</a>
    <a class="collapse-target" href="#modal2">target 2</a>
    <a class="collapse-target" href="#modal3">target 3</a>
    <a class="collapse-target" href="#modal4">target 4</a>
    <div class="collapse-body" id="modal1">target 1</div>
    <div class="collapse-body" id="modal2">target 2</div>
    <div class="collapse-body" id="modal3">target 3</div>
    <div class="collapse-body" id="modal4">target 4</div>
</div>
```

```css
.t-collapse>.collapse-body { display: none;}
.t-collapse>.collapse-body:target {display: block;}
```

## 2.2 js随机排序方法使用

### 2.2.1 随机交换元素

- 遍历数组，每次循环都随机一个在数组长度范围内的数，并交换本次循环的位置和随机数位置上的元素

  ```js
  var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  function randSort1(arr) {
      for (var i = 0, len = arr.length; i < len; i++) {
          var rand = parseInt(Math.random() * len);
          var temp = arr[rand];
          arr[rand] = arr[i];
          arr[i] = temp;
      }
      return arr;
  }
  console.log(randSort1(arr));
  ```

###2.2.2 截取出随机数位置上的元素

- 申明一个新的空数组,利用while循环，如果数组长度大于0，就继续循环； 

- 每次循环都随机一个在数组长度范围内的数，将随机数位置上的元素push到新数组里， 

- 并利用splice截取出随机数位置上的元素，同时也修改了原始数组的长度；

  ```js
  var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  function randSort(arr) {
      var mixedArray = [];
      while (arr.length > 0) {
          var randomIndex = parseInt(Math.random() * arr.length);
          mixedArray.push(arr[randomIndex]);
          arr.splice(randomIndex, 1);
      }
      return mixedArray;
  }
  console.log(randSort(arr));
  ```

### 2.2.3 利用传入sort排序中的比较函数

- 思路：利用传入sort排序中的比较函数,比较函数的规则如下： 

1. 如果 compareFunction(a, b)的返回值 小于 0 ，那么 a 会被排列到 b 之前； 

2. 如果 compareFunction(a, b)的返回值 等于 0 ，那么a 和 b 的相对位置不变； 

3. 如果 compareFunction(a, b)的返回值 大于 0 ，那么b 会被排列到 a 之前；

  ```js
  var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  arr.sort(function () {
      return Math.random() - 0.5;
  })
  console.log(arr);
  ```

### 2.2.4 一个典型的DOM随机排序方法

```js
function randromSort(divname) {
        var randromArray = new Array();
        var i = 0;
        $("div[name=" + divname + "]").each(function() {
            randromArray[i] = $(this).clone(true);
            i = i + 1;
        });
        $("div[name=" + divname + "]").each(function() {
            var t = Math.floor(Math.random() * i);
            $(this).replaceWith(randromArray[t]);
            randromArray.splice(t, 1);
            i = i - 1;
        });
    }
```

## 2.3 页面性能检测方法

```js
使用API:performance.getEntriesByType('navigati')
```

 







# 二、各种知识点

## 2.1 适配iphoneX刘海屏方法

方法1，在meta标签中增加`viewport-fit=cover"`

`<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, viewport-fit=cover">`

方法2，使用媒体查询：

```javascript
/*iPhoneX的适配*/
@media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) {
    html,bodey{
        height:812px
    }
} 
```

##2.2 webpack中static目录文件不打包

## 2.2、WebSocket——socket.io

### 2.2.1、服务端

  a.先有个http服务

```javascript
let server=http.createServer();
    server.listen(4311); 
```

  b.再有个ws服务

```javascript
   let wsServer=io.listen(server);
    wsServer.on('connection', function (sock){
      sock
    })
```

### 2.2.2、浏览器

  a.引库
    <script src="xxxx/socket.io/socket.io.js"></script>

  b.连接
    let sock=io.connect('ws://xxxx/');

###2.2.3、传递数据

```js
浏览器或服务端可通过如下方法传递数据：
sock.emit('名字', 参数...);
sock.on('名字', function (参数...){});
```

###2.2.4、连接断开或离线

```javascript
sock.on('disconnect',function(){	 //会触发
    console.log('连续断开')
})
```

## 2.3、promise封装

~~~javascript
    class Promise2{
      constructor(fn){
        const _this=this;
        //重点
        this.__queue=[];
        this.__succ_res=null;
        this.__erro_res=null;
        this.status='';
        fn(function (...arg){
          _this.__succ_res=arg;
          _this.status='succ';
          _this.__queue.forEach(json=>{
            json.fn1(...arg);
          });
        }, function (...arg){
          _this.__erro_res=arg;
          _this.status='error';
          _this.__queue.forEach(json=>{
            json.fn2(...arg);
          });
        });
      }
      then(fn1, fn2){
        if(this.status=='succ'){
          fn1(...this.__succ_res);
        }else if(this.status=='error'){
          fn2(...this.__erro_res);
        }else{
          this.__queue.push({fn1, fn2});
        }
      }
    }
    Promise2.all=function (arr){
      let arr=[];
      return Promise2(function (resolve, reject){
        let i=0;
        function next(){
          arr[i].then(function (res){
            arr.push(res);
            i++;
            if(i==arr.length){
              resolve(arr);
            }else{
              next();
            }
          }, reject);
        }
      });
    };

    let p=new Promise2(function (resolve, reject){
      setTimeout(function (){
        resolve(12);
      }, 500);
    });

    p.then(function (num){
      alert(num);
    }, function (){
      alert('错误');
    });

~~~

## 2.4、管理数据的可视图软件naticat

## 2.5、简单的SQL语句

###2.5.1、增  	

```sql
INSERT INTO 表(字段列表) VALUES(值)
INSERT INTO user_table (username,password,online) VALUES ('张三','123456',0)
```

###2.5.2、删

```sql
DELTE FROM 表 WHERE 条件
DELETE FROM　user_table WHERE ID=3
```

### 2.5.3、改

```sql
UPDATE 表 SET 字段=新值,字段=新值,…  WHERE 条件
UPDATE user_table SET password='111111111' WHERE ID=2
```

### 2.5.4、查

```sql
SELECT 字段列表 FROM 表 WHERE 条件
SELECT username,online FROM user_table WHERE ID=1

//模糊搜索
SELECT * FROM Persons WHERE City LIKE 'N%'   //搜索城市名为N开头
SELECT * FROM Persons WHERE City LIKE '%g'   //搜索城市名为g结尾
SELECT * FROM Persons WHERE City LIKE '%lon%'  //搜索城市名包含lon
SELECT * FROM Persons WHERE City NOT LIKE '%lon%'  //搜索城市名不包含lon
```

##2.6、H5部分补充点

###2.6.1 定位api的使用

```javascript
if(window.navigator.geolocation){                 // 获取地址
          navigator.geolocation.getCurrentPosition(function (res){
            alert('成功');
            console.log(res);
          }, function (err){
            alert('失败');
          }, {
            //enableHighAccuracy          //高精度模式
            //timeout                     //超时时间
            //maximumAge                  //缓存
          });
        }else{
          alert('你的浏览器不支持定位');
        }


if(window.navigator.geolocation){         //观察地址变化
          var watchID=navigator.geolocation.watchPosition(function (res){
            alert('成功');
            console.log(res);
          }, function (err){
            alert('失败');
          }, {
            //enableHighAccuracy          //高精度模式
            //timeout                     //超时时间
            //maximumAge                  //缓存
            //frequency:    1000  		 //定位更新频率
          });
        }else{
          alert('你的浏览器不支持定位');
        }

        //navigator.geolocation.clearWatch(watchID);
      
```

### 2.6.2 webworket多进程创建和使用

> * 方法一

```javascript
// 不能执行任何UI操作，子进程只能执行计算型任务
    //1.创建子进程    主js文件创建
    let w=new Worker('w1.js');   // 引入js文件
    //2.发送
    w.postMessage({n1, n2});
    //6.接收结果
    w.onmessage=function (ev){
        alert(ev.data);
    };

    //3.接收 		w1.js文件
    this.onmessage=function (ev){
      //console.log('我得到了：', ev.data);
      //4.处理任务
      let sum=ev.data.n1+ev.data.n2;
      //5.返回
      this.postMessage(sum);
    };
```

> * 方法二

```javascript
// nodejs中创建子进程     主进程文件
const http = require('http');   
const fork = require('child_process').fork;
const server = http.createServer((req, res) => {
    if (req.url == '/compute') {
        const compute = fork('./fork_compute.js');
        compute.send('开启一个新的子进程');
        // 当一个子进程使用 process.send() 发送消息时会触发 'message' 事件
        compute.on('message', sum => {
            res.end(`Sum is ${sum}`);
            compute.kill();
        });

        // 子进程监听到一些错误消息退出
        compute.on('close', (code, signal) => {
            console.log(`收到close事件，子进程收到信号 ${signal} 而终止，退出码 ${code}`);
            compute.kill();
        })
    } else {
        res.end(`ok`);
    }
});
server.listen(3000, () => {
    console.log('server started at http://127.0.0.1:3000'+'serverPID='+process.pid);
});


// 子进程文件
const computation = () => {
    let sum = 0;
    console.info('计算开始');
    console.time('计算耗时');
    for (let i = 0; i < 1e10; i++) {
        sum += i
    };
    console.info('计算结束');
    console.timeEnd('计算耗时');
    return sum;
};

process.on('message', msg => {
    console.log(msg, 'process.pid', process.pid); // 子进程id
    const sum = computation();
    // 如果Node.js进程是通过进程间通信产生的，那么，process.send()方法可以用来给父进程发送消息
    process.send(sum);
})
```



### 2.6.3 拖拽事件

```javascript
oDiv.addEventListener('dragenter', function (){     //ondragenter     进入
    oDiv.innerHTML='释放鼠标';
}, false);

oDiv.addEventListener('dragleave', function (){     //ondragleave     离开
    oDiv.innerHTML='将文件拖拽至此区域';
}, false);

oDiv.addEventListener('dragover', function (ev){    //ondragover  悬停——只要没走，就一直发生
    console.log('dragover');
    ev.preventDefault();
}, false);

// 松开鼠标——如果dragover不阻止默认事件，drop压根不会发生
oDiv.addEventListener('drop', function (ev){
    console.log(ev.dataTransfer.files); // 获取传输的文件
    ev.preventDefault();
}, false);

```

### 2.6.4 文件操作相关

```javascript
	oDiv.addEventListener('drop', function (ev){
        ev.preventDefault();
        //
        let oFile=ev.dataTransfer.files[0];
        //读取
        let reader=new FileReader();
        reader.onload=function (){
          console.log(this.result);
        };
        reader.onerror=function (){
          alert('读取失败了');
        };
        reader.readAsText(oFile)            //文本                    文本文件
        reader.readAsDataURL(oFile)         //base64                  图片
        reader.readAsArrayBuffer(oFile)     //原始二进制数据           编辑（不实用）
        reader.readAsBinaryString(oFile)    //二进制的文本形式数据     上传
      }, false);
```

### 2.6.5 canvas相关的操作补充

使用路径之前——先beginPath   与路径操作配合使用
使用变换之前——先save、后restore     与变形transform和rotale等配合使用

####2.6.5.1 canvas像素级操作

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title></title>
    <script>
    window.onload=function (){
      let oC=document.getElementById('c1');
      let oBtn1=document.getElementById('btn1');
      let oBtn2=document.getElementById('btn2');
      let oBtn3=document.getElementById('btn3');
      let gd=oC.getContext('2d');
      //每个像素占4位   r g b a         0~255
      let oImg=new Image();
      oImg.src='1.jpg';
      oImg.onload=function (){
        gd.drawImage(oImg, 0, 0);
        oBtn1.onclick=function (){
          let imageData=gd.getImageData(0, 0, oC.width, oC.height);    //获取像素区
          //data[(r*W+c)*4]
          for(let r=0;r<oC.height;r++){
            for(let c=0;c<oC.width;c++){
              let avg=(imageData.data[(r*oC.width+c)*4]+imageData.data[(r*oC.width+c)*4+1]+
                       imageData.data[(r*oC.width+c)*4+2])/3;
              imageData.data[(r*oC.width+c)*4]=imageData.data[(r*oC.width+c)*4+1]=
                  imageData.data[(r*oC.width+c)*4+2]=avg;
            }
          }
          gd.putImageData(imageData, 0, 0);
        };
        oBtn2.onclick=function (){
          let imageData=gd.getImageData(0, 0, oC.width, oC.height);       //获取像素区
          //data[(r*W+c)*4]
          for(let r=0;r<oC.height;r++){
            for(let c=0;c<oC.width;c++){
              imageData.data[(r*oC.width+c)*4+2]=0;
            }
          }
          gd.putImageData(imageData, 0, 0);
        };

        oBtn3.onclick=function (){
          let imageData=gd.getImageData(0, 0, oC.width, oC.height);  //获取像素区
          //data[(r*W+c)*4]
          for(let r=0;r<oC.height;r++){
            for(let c=0;c<oC.width;c++){
              imageData.data[(r*oC.width+c)*4+0]=0;
              imageData.data[(r*oC.width+c)*4+2]=0;
            }
          }
          gd.putImageData(imageData, 0, 0);
        };
      };
    };
    </script>
  </head>
  <body>
    <input type="button" name="" value="变灰" id="btn1">
    <input type="button" name="" value="变黄" id="btn2">
    <input type="button" name="" value="变绿" id="btn3"><br>
    <canvas id="c1" width="800" height="600"></canvas>
  </body>
</html>
```

#### 2.6.5.2 canvas画video

```javascript
<video id="v1" src="a.mp4" controls></video>
<canvas id="c1" width="636" height="360"></canvas>

let oV=document.getElementById('v1');   //获取video
let oC=document.getElementById('c1');   //获取canvas
let gd=oC.getContext('2d');			//获取画笔
gd.drawImage(oV, 0, 0);		//将video画进canvas中，此时只能画一帧，需设置定时器
```

使用requestAnimationFrame来处理视频（加滤镜等操作）

```javascript
 requestAnimationFrame(function (){
          //画
          gd.drawImage(oV, 0, 0);  //将视频画上

          //取
          let imageData=gd.getImageData(0, 0, oC.width, oC.height); //取该一帧的画面

          for(let r=0;r<oC.height;r++){
            for(let c=0;c<oC.width;c++){  //双循环来获取每个画面的像素点
              let color=(imageData.data[(r*oC.width+c)*4]+
                         imageData.data[(r*oC.width+c)*4+1]+
                         imageData.data[(r*oC.width+c)*4+2])/3 

              imageData.data[(r*oC.width+c)*4]=
              imageData.data[(r*oC.width+c)*4+1]=
              imageData.data[(r*oC.width+c)*4+2]=color;  //将每个像素点的颜色都进行处理
            }
          }
          gd.putImageData(imageData, 0, 0);	 //将更改后的像素点重画上
        })
```

#### 2.6.5.3 使用canvas画图传至服务端

```javascript
    let gd=oC.getContext('2d'); 
    let str=oC.toDataURL(); //1.将画好的图片转成base64字符串
    //2.发给服务器
    let xhr=new XMLHttpRequest();
    xhr.open('post', '/upload_base64', true);
    xhr.send(encodeURIComponent(str));   //base64位需编码
    xhr.onreadystatechange=function (){
        if(xhr.readyState==4){
            alert(xhr.status);
        }
    }
```

#### 2.6.5.4 将input获取的文件画在页面上

```javascript
let reader=new FileReader();
reader.onload=function (){
    let oImg=new Image();
    oImg.src=this.result;
    oImg.onload=function (){
        gd.drawImage(oImg, 0, 0);
    }
    reader.readAsDataURL(oF.files[0]);
}
```

#### 2.6.5.5 拖拽文件至页面上显示

```javascript
oBox.addEventListener('drop', function (ev){
    ev.preventDefault();
    //
    let formData=new FormData();
    Array.from(ev.dataTransfer.files).forEach(file=>{
        formData.append('f1', file);
    });
    
    //ajax
    let xhr=new XMLHttpRequest();
    xhr.upload.onprogress=function (ev){
        oM.value=Math.floor(100*ev.loaded/ev.total);
    };
    xhr.upload.onload=function (){
        alert('上传完成');
    };

    xhr.open('post', '/upload', true);
    xhr.send(formData);

    //服务器返回
    xhr.onreadystatechange=function (){
        if(xhr.readyState==4){
            alert(xhr.status);
        }
    };
}, false);
```

###2.6.6 ajax上传文件等内容方法

ajax一切操作都是在模拟表单，一般使用FormData对象来构建表单

```js
oAjax.send(formData) //ajax发送FormData
formData.set(名字, 值); //form提供的方法，值可为file
formData.append(名字, 值); //form提供的方法，值可为file,append可增加多个文件
```

#### 2.6.6.1 上传进度实现

| onabort                            | 终止     |
| ---------------------------------- | -------- |
| onerror                            | 错误     |
| onload                             | 完成     |
| onloadstart                        | 开始     |
| onloadend                          | 结束     |
| onprogress(**ev.loaded/ev.total**) | 进度变化 |
| ontimeout                          | 超时     |

```javascript
    let oAjax=new XMLHttpRequest();
    //进度
    oAjax.upload.onerror=function (){   // upload方法要放在open方法前
        alert('上传出错，请稍候重试');
    };
    oAjax.upload.onload=function (){
        alert('上传完成');
    };
    oAjax.upload.onprogress=function (ev){ // ev.loaded/ev.total可以获取到进度
        let str=(100*ev.loaded/ev.total).toFixed(2)+'%'; 
        let oChild=document.querySelector('.child');
        oChild.style.width=str;
    };

    oAjax.open('POST', '/upload', true);

    //表单
    let formData=new FormData();
    aFile.forEach(oFile=>{
        Array.from(oFile.files).forEach(file=>{
            formData.append('f1', file);
        });
    });

    oAjax.send(formData);

    oAjax.onreadystatechange=function (){
        if(oAjax.readyState==4){
            alert(oAjax.status);
        }
```

#### 2.6.6.2 上传图片或文件时node的处理

```javascript
//读取文件 readFile(文件名, [编码,] cb)
const fs=require('fs');
fs.readFile('1.gif', 'base64', (err, data)=>{   
  if(err){
    console.log('读取失败');
  }else{
    console.log(data);
  }
});
//写入文件writeFile(文件名, 东西, [编码,] cb)
```

```javascript
//使用POST请求获取base64位格式的图片   GET	1个包   POST	n个包  post数据必须分很多次接收
const http=require('http');
let server=http.createServer((req, res)=>{
  //注意：下面的post接收方式有瑕疵
  let str='';
  req.on('data', data=>{
    str+=data;
  });
  req.on('end', ()=>{
    console.log('post数据接收完了', str);
  });
});
server.listen(8080);
```

```javascript
//一个完整的POST请求
const http=require('http');
const fs=require('fs');
const url=require('url');
const uuidv4=require('uuid/v4');

let server=http.createServer((req, res)=>{
  const {pathname, query}=url.parse(req.url, true);
  if(pathname=='/upload_base64'){
    //3.接收字符串
    let str='';       //问题不大——以后再改
    req.on('data', data=>{
      str+=data;
    });
    req.on('end', ()=>{
      str=decodeURIComponent(str);
      str=str.replace(/data:[a-z\-]+(\/[a-z\-]+)?;base64,/i, '');
      //4.保存下来
      fs.writeFile(`./www/upload/${uuidv4().replace(/\-/g, '')}`, str, 'base64', err=>{
        if(err){
          res.writeHeader(500);
          res.write('write file error');
        }else{
          res.write('ok');
        }
        res.end();
      });
    });
  }else{
    fs.readFile(`./www${pathname}`, (err, data)=>{
      if(err){
        res.writeHeader(404);
        res.write('not found');
      }else{
        res.write(data);
      }
      res.end();
    });
  }
});
server.listen(8080);
```

### 2.6.7 requestAnimationFrame()

```javascript
requestAnimationFrame(function (){   //向浏览器请求一帧，传递一个回调函数循环执行
    gd.drawImage(oV, 0, 0)		//每隔一帧执行一次该操作
 })
```

### 2.6.8 SVG相关操作

####2.6.8.1 SVG相关操作方法

- stroke: #70d5dd;      fill: #dd524b ;     stroke-width="1" 可写在style中，也可直接以属性写在标签中

- svg的样式两种写法：
  1.属性形式
  2.style形式     推荐以行内样式写上，因为其优先级最低

- SVG图形：
  1.样式操作        跟HTML一样(推荐用style)
  2.事件操作        跟HTML一样(完全一样)
  3.属性操作        有点区别(set/get)
        HTML                       SVG
  设置  .xxx=xxx              .setAttribute
        .setAttribute
  获取  .xxx                       .getAttribute
        .getAttribute

- DOM操作
    获取            完全一样
    创建            HTML: createElement
                        SVG: createElementNS('http://www.w3.org/2000/svg')
    插入            完全一样

- 图形
  1.rect       矩形        x,y,width,height,rx,ry
  2.circle     正圆        cx,cy,r
  3.ellipse   椭圆       cx,cy,rx,ry
  4.line        直线        x1,y1,x2,y2
  5.多边形

  6.path(路径)
    M     x,y
    L     (x,y)+
    Z
    A     rx          ry          x-axis-rotation     large-arc-flag         sweep-flag       x           y
           x半径    y半径    x轴旋转                 大弧标志(0,1)          镜像标志          终点x    y

  注意：如果没有背景色(fill:none)，会导致背景没有事件——用透明

  

####2.6.8.2 SVG画相关图形

```javascript
<!-- 画圆 -->
<svg width="300" height="180">
    <circle cx="30" cy="50" r="25" />
    <circle cx="90" cy="50" r="25" class="red" />
    <circle cx="150" cy="50" r="25" class="fancy" />
</svg>

<!-- 直线 -->
<svg width="300" height="180">
    <line x1="0" y1="0" x2="200" y2="0" style="stroke:rgb(0,0,0);stroke-width:5" />
</svg>

<!-- 折线 -->
<svg width="300" height="180">
    <polyline points="3,3 30,28 3,53" fill="none" stroke="black" />
</svg>

<!-- 矩形 -->
<svg width="300" height="180">
    <rect x="0" y="0" height="100" width="200" style="stroke: #70d5dd; fill: #dd524b" />
</svg>

<!-- 椭圆 -->
<svg width="300" height="180">
    <ellipse cx="60" cy="60" ry="40" rx="20" stroke="black" stroke-width="5" fill="silver" />
</svg>

<!-- 多边形 -->
<svg width="300" height="180">
    <polygon fill="green" stroke="orange" stroke-width="1" points="0,0 100,0 100,100 0,100 0,0" />
</svg>

<!-- 路径 -->
<svg width="300" height="180">
    <path d="
             M 18,3
             L 46,3
             L 46,40
             L 61,40
             L 32,68
             L 3,40
             L 18,40
             Z
             ">
    </path>
</svg>

<!-- 文本 -->
<svg width="300" height="180">
    <text x="50" y="25" style="stroke: #70d5dd; fill: #dd524b">Hello World</text>
</svg>

<!-- 复制形状 -->
<svg viewBox="0 0 30 10" xmlns="http://www.w3.org/2000/svg">
    <circle id="myCircle" cx="5" cy="5" r="4" />
    <use href="#myCircle" x="10" y="0" fill="blue" />
    <use href="#myCircle" x="20" y="0" fill="white" stroke="blue" />
</svg>

<!-- 多个形状组成一个组 -->
<svg width="300" height="100">
    <g id="myCircle">
        <text x="25" y="20">圆形</text>
        <circle cx="50" cy="50" r="20" />
    </g>
    <use href="#myCircle" x="100" y="0" fill="blue" />
    <use href="#myCircle" x="200" y="0" fill="white" stroke="blue" />
</svg>

<!-- 自定义形状，它内部的代码不会显示 -->
<svg width="300" height="100">
    <defs>
        <g id="myCircle">
            <text x="25" y="20">圆形</text>
            <circle cx="50" cy="50" r="20" />
        </g>
    </defs>
    <use href="#myCircle" x="0" y="0" />
    <use href="#myCircle" x="100" y="0" fill="blue" />
    <use href="#myCircle" x="200" y="0" fill="white" stroke="blue" />
</svg>

<!-- <pattern>标签用于自定义一个形状 -->
<svg width="500" height="500">
    <defs>
        <pattern id="dots" x="0" y="0" width="100" height="100" 				
                 patternUnits="userSpaceOnUse">
            <circle fill="#bee9e8" cx="50" cy="50" r="35" />
        </pattern>
    </defs>
    <rect x="0" y="0" width="100%" height="100%" fill="url(#dots)" />
</svg>

<!-- <animate>标签用于产生动画效果。 -->
<svg width="500px" height="100px">
    <rect x="0" y="0" width="100" height="100" fill="#feac5e">
        <animate attributeName="x" from="0" to="500" dur="2s" repeatCount="indefinite" />
        <animate attributeName="width" to="500" dur="2s" repeatCount="indefinite" />
    </rect>
</svg>

<!-- <animateTransform>标签 -->
<svg width="500px" height="500px">
    <rect x="250" y="250" width="50" height="50" fill="#4bc0c8">
        <animateTransform attributeName="transform" type="rotate" begin="0s" dur="10s" 				from="0 200 200" to="360 400 400" repeatCount="indefinite" />
    </rect>
</svg>
```

## 2.7 Raphael.js使用

能兼容VML和SVG，并且有扩展功能——动画

```javascript
//1.创建画布
let paper=Raphael(x,y,width,height);

//2.创建形状
let rect=paper.rect(x,y,width,height);
let path=paper.path("M 100 100 L 400 100 400 300 100 300 Z")

//3.设置属性(样式)
rect.attr({fill: 'red', stroke: 'green'});  //填充样式
path.attr('stroke-width', 20);    //边线样式
path.attr('stroke-linejoin', 'miter');  
path.attr('stroke-miterlimit', '5');
path.attr('stroke-dasharray', '--..');

//4.事件
path.hover(function (){
    this.attr('fill', 'green');
}, function (){
    this.attr('fill', 'yellow');
});

//5.过渡
rect.click(function (){
    //this.attr('transform', 's2,1 r30');
    // x轴放大两倍，Y轴放大一倍，旋转30度
    this.animate({'transform': 's2,1 r30'}, 1000, 'linear'); 
});

//6.动画
// 'linear', 'easeIn', 'easeOut', 'easeInOut', 'backIn', 'backOut', 'elastic', 'bounce'
rect.animate({'x': 600}, 3000, 'linear');  //位置动画
rect.animate({'fill': 'green'}, 2000);     //填充动画
rect.animate({'stroke-width': '20'}, 2000); //描边动画
rect.animate({'path': 'M 100 100 L 400 100 400 300 100 300 Z'}, 700, 'bounce'); //路径
```

### 2.7.1 形状

| 名称    | 参数                     | 说明 |
| ------- | ------------------------ | ---- |
| rect    | x, y, width, height, [r] | 矩形 |
| circle  | cx, cy, r                | 圆   |
| ellipse | cx, cy, rx, ry           | 椭圆 |
| image   | src, x, y, width, height | 图片 |
| path    | pathString               | 路径 |
| text    | x, y, text               | 文字 |

### 2.7.2 事件

| 名称                    | 说明       |
| ----------------------- | ---------- |
| click/unclick           | 点击       |
| dblclick/undblclick     | 双击       |
| hover/hover             | 移入、移出 |
| mousedown/unmousedown   | 鼠标按下   |
| mousemove/unmousemove   | 鼠标移动   |
| mouseup/unmouseup       | 鼠标抬起   |
| touchstart/untouchstart | 手指按下   |
| touchmove/untouchmove   | 手指移动   |
| touchend/untouchend     | 手指抬起   |

### 2.7.3 transform

transform以字符串形式写，例如：`"t200,50r45s2"`

| 命令 | 说明      | 参数  |
| ---- | --------- | ----- |
| t    | translate | x,y   |
| r    | rotate    | angle |
| s    | scale     | x,y   |

### 2.7.4 路径

| 命令 | 说明                                                 | 参数                                                   |
| -------- | ---------------------------------------------------- | ------------------------------------------------------ |
| M    | moveto                                               | (x y)+                                                 |
| Z    | 闭合                                                 |                                                        |
| L    | lineto                                               | (x y)+                                                 |
| H    | 横线(horizontal)                                     | x+                                                     |
| V    | 竖线(vertical)                                       | y+                                                     |
| C    | 曲线(curve)                                          | (x1 y1 x2 y2 x y)+                                     |
| S    | 平滑曲线(smooth)                                     | (x2 y2 x y)+                                           |
| Q    | 二次贝赛尔曲线(quadratic)                            | (x1 y1 x y)+                                           |
| T    | 平滑二次贝塞尔曲线                                   | (x y)+                                                 |
| A    | 弧线(arc)                                            | (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+ |
| R    | 卡特莫尔罗曲线(CatmullRom)——抗锯齿平滑曲线的一种算法 | x1 y1 (x y)+                                           |

### 2.7.5 属性

| 名称              | 类型     | 说明                                                         |
| ----------------------------- | -------- | ------------------------------------------------------------ |
| x                 | `number` |                                                              |
| y                 | `number` |                                                              |
| width             | `number` |                                                              |
| height            | `height` |                                                              |
| rx                | `number` | 圆角x                                                        |
| ry                | `number` | 圆角y                                                        |
| cx                | `number` | 圆心x                                                        |
| cy                | `number` | 圆心y                                                        |
| r                 | `number` | 半径                                                         |
| opacity           | `number` | 透明度                                                       |
| path              | `string` | path字符串                                                   |
| src               | `string` | 图片地址，只有image元素可用                                  |
| transform         | `string` | 类似transform()方法                                          |
| **边线样式**      |          |                                                              |
| stroke            | `string` | 边线，只能是颜色                                             |
| stroke-width      | `number` | 边线宽度                                                     |
| stroke-linecap    | `string` | 端点形状：[“butt”, “square”, “round”]                        |
| stroke-linejoin   | `string` | 接头形状：[“bevel”, “round”, “miter”]                        |
| stroke-dasharray  | `string` | 边线虚线，-和.组成："-.-"/"-"/"--.._..--"                    |
| stroke-miterlimit | `number` | 斜接长度限制，只有当接头是miter时有效                        |
| stroke-opacity    | `number` | 边线透明度                                                   |
| **填充样式**      |          |                                                              |
| fill              | `number` | 填充，可以是颜色、渐变或图片                                 |
| fill-opacity      | `number` | 填充透明度                                                   |
| **字体**          |          |                                                              |
| font              | `string` | 类似于css的font                                              |
| font-family       | `string` | 字体                                                         |
| font-size         | `number` | 字体大小                                                     |
| font-weight       | `string` | 加粗                                                         |
| text              | `string` | text元素的文字内容                                           |
| text-anchor       | `string` | 文本对齐：[“start”, “middle”, “end”]                         |
| title             | `string` | text的tooltip                                                |
| href              | `string` | 链接地址                                                     |
| target            | `string` | 链接target                                                   |
| **其他**          |          |                                                              |
| cursor            | `string` | 鼠标指针，类似于css的cursor样式                              |
| arrow-end         | `string` | arrowhead on the end of the path. The format for string is [-[-]]. Possible types: classic, block, open, oval, diamond, none, width: wide, narrow, midium, length: long, short, midium. |
| clip-rect         | `string` | comma or space separated values: x, y, width and height      |

## 2.8 echarts使用

### 2.8.1 使用步骤

```javascript
let box = document.querySelector('.box')
let charts=echarts.init(box)
let option={
    title:      //标题
    xAxis:      //柱状图x轴
    yAxis:      //柱状图y轴
    legend: {   //指示器
          data: ['男', '女'],
          right: 0,
          top: '50%',
          orient: 'vertical'
        },
    series:[    数据
        {
        name: '名字',
        type: 'bar/pie/radar',   //图形类型
        data: [数据]
       }
	]
};
charts.setOption(option);   //设置选项
charts.on('mouseover', function (ev){  //事件
     console.log(v.name)
 });
```

### 2.8.2 典型的柱状图

```javascript
let oBox=$('.box')[0];
let option={
    title: {
        text: '北京人口数量',
        subtext: '2017年(单位：万)'
    },
    legend: {
        data: ['男', '女'],
        right: 0,
        top: '50%',
        orient: 'vertical'
    },
    xAxis: [
        {
            type: 'category',
            data: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', 
                   '11月', '12月']
        }
    ],
    yAxis: [
        {
            type: 'value'
        }
    ],
    series: [
        {
            name: '男',
            type: 'bar',
            data: [1352, 23, 1354, 1354, 1355, 1356, 1364, 1454, 1334, 1254, 1350, 754]
        },
        {
            name: '女',
            type: 'bar',
            data: [1245, 12, 1254, 1254, 1255, 1256, 1464, 1354, 1234, 1154, 1250, 454]
        }
    ],
    animationEasing: 'bounceOut',
    animationDelayUpdate(index){
        return index*700
 }
```

### 2.8.3 典型饼图

```js
let oBox=document.querySelector('.box')
let option={
    title: {
        text: '北京人口数量',
        subtext: '2017年(单位：万)'
    },
    series: [ //数组，可传多对象，生成几个饼
        {
            name: '学历比例',
            type: 'pie',
            radius: '20%',  //饼图半径
            center: ['30%', '50%'],
            data: [
                {name:'小学', value:350},
                {name:'中学', value:120},
                {name:'大学', value:1524},
                {name:'研究生', value:410},
                {name:'博士及以上', value:85},
            ]
        },
        {
            name: '性别比例',
            type: 'pie',
            //radius: '60%',
            radius: ['70%', '80%'],
            center: ['70%', '50%'],
            data: [
                {name:'男', value:2752},
                {name:'女', value:1985},
                {name:'其他', value:3},
            ]
        }
    ]
};
let charts=echarts.init(oBox);
charts.setOption(option);
```

### 2.8.4 雷达图

```js
let option={
    title: {
        text: '北京人口数量',
        subtext: '2017年(单位：万)'
    },
    legend: { 
        data: ['角色', '敌人'],
        right: 0,
        top: '50%',
        orient: 'vertical'
    },
    radar: {   //雷达图传用配置
        indicator: [
            {name: 'HP', max: 9999},
            {name: '攻击', max: 99},
            {name: '防御', max: 99},
            {name: '魔法', max: 99},
        ]
    },
    series: [
        {
            name: '属性',
            type: 'radar',
            data: [
                {
                    name: '角色',
                    value: [1570, 23, 65, 17]
                },
                {
                    name: '敌人',
                    value: [2300, 89, 76, 65]
                }
            ]
        }
    ]
};
let charts=echarts.init(oBox);
charts.setOption(option);
```

## 2.9 D3使用

D3可以分着用、也能合着用，主要有以下特性

| --          | --       |
| ----------- | -------- |
| Arrays      | 数组     |
| Colors      | 颜色     |
| Collections | 数据结构 |
| Forces      | 物理计算 |
| Scales+Axes |          |

>d3的核心
>****************************************************
>1.访问器——抽出特征
>2.生成器——批量处理数据(高性能)
>
>--------------------------------------------------------------------------------
>
>d3也能做dom操作
>d3.select('父级').append('标签').attr().style()
>
>--------------------------------------------------------------------------------
>
>d3——计算库
>
>图表：
>数据->计算=>{角度...}=>计算=>{点坐标, 点2坐标, ...}->生成path

### 2.9.1 D3提供的数组及颜色等方法

```js
//数组相关操作
d3.max([12,5,8,99,27])    //数组最大值
d3.extent([12,5,8,99,27])  //数组最大值和最小值
```

```js
//颜色相关操作,均可获取rgb值
console.log(d3.color('red')); 
console.log(d3.color('#f00'));  
console.log(d3.color('rgb(255,0,0)'));
console.log(d3.color('rgba(255,0,0,0.3)'));
console.log(d3.color('rgba(50%,30%,30%,0.3)'));  
console.log(d3.color('rgba(50%,0%,30%,0.3)')); 
```

```js
//map和set相关操作
let map=d3.map([{name: 'blue', age: 18}, {name: 'alex', age: 25}, 
                {name: 'tom', age: 27}], item=>item.age);
console.log(map.get(25));

let set=d3.set([{name: 'blue', age: 18}, {name: 'alex', age: 25},
                {name: 'tom', age: 27}], item=>item.age);
console.log(set.has('blue'));
```

```js
//数字格式化生成器
let gen=d3.format('10.3f');  
console.log(gen(128.555555)); //生成器处理数据

//日期格式化生成器
let gen=d3.timeFormat('%Y年%m月%d日 %H:%M:%S');
console.log(gen(Date.now()));  //生成器处理时间
```

```js
//随机数
let gen=d3.randomUniform(5, 20);     //均值分布
let gen=d3.randomNormal(15);         //正态分布(高斯分布)
```

```js
//D3做DOM操作
d3.select('body')
    .append('div')
    .style('width', '300px')
    .style('height', '200px')
    .style('background', 'red')

//D3操作SVG
d3.select('body')
    .append('svg')
    .attr('width', 800)
    .attr('height', 600)
    .append('path')
    .attr('d', "M 100,100 L 300,200 200,100")
    .attr('stroke', 'black')
    .attr('fill', 'none')
```

### 2.9.3 绘制折线图

```js
let datas=[    //数据
    {name: '1月', value: 1750},
    {name: '2月', value: 541},
    {name: '3月', value: 875},
    {name: '4月', value: 3752},
    {name: '5月', value: 548},
    {name: '6月', value: 987}
];

//1.计算——点坐标...
let lineGen=d3.line()   //1.1.创建生成器
    .x(item=>(parseInt(item.name)-1)*(10+780/(datas.length-1)))
    .y(item=>500-item.value/10)

let res=lineGen(datas); //1.2.拿着生成器计算东西
console.log(res); //获取每个点的坐标

//2.创建图形来显示数据
d3.select('body')
    .append('svg')
    .attr('width', 800)
    .attr('height', 600)
    .style('border', '1px solid black')
    .append('path')
    .attr('d', res)
    .attr('stroke', 'black')
    .attr('fill', 'none')
```

### 2.9.4 绘制饼图

```js
let datas=[
    {name: '不及格', value: 68},
    {name: '及格', value: 276},
    {name: '优秀', value: 53},
    {name: '满分', value: 23}
];

let svg=d3.select('body').append('svg').attr('width', 800)
						 .attr('height', 600).style('border', '1px solid black');
let g=svg.append('g');
let paths=[];

//1.计算
let pie=d3.pie().value(item=>item.value).padAngle(3*Math.PI/180)  //1.1.计算每一个pie的角度
let pieRes=pie(datas);
console.log(pieRes);

let arc=d3.arc().innerRadius(130).outerRadius(150)  //1.2.计算每一个点的坐标
let rnd=d3.randomUniform(0, 100);

pieRes.forEach(pieData=>{
    let arcRes=arc(pieData);
    console.log(arcRes);

    //2.生成
    let path=g.append('path')
        .attr('d', arcRes)
        .attr('stroke', 'none')
        .attr('fill', d3.color(`rgb(${rnd()}%,${rnd()}%,${rnd()}%)`))
    paths.push(path);
});

//整组一起移动
g.attr('transform', 'translate(400, 300) rotate(30)');

//paths
let oBtn=document.getElementById('btn1');
oBtn.onclick=function (){
    paths[0].remove();
    //paths[0].attr('fill', 'yellow');
    datas.splice(0, 1);
};
```

# 三、综合项目

## 3.1  Node模块

- url模块-----解析url

  ```js
  const url=require('url'); //直接引入
  let obj=url.parse("https://locathost:3000?a=1&b=2", true);  //true可将query分隔成对象
  console.log(obj);
  ```

- querystring模块----解析url中参数

  ```js
  const querystring=require('querystring');  //直接引入
  let str="wd=abcdd&rsv_spt=1";
  let obj=querystring.parse(str);  //将参数解析成对象
  console.log(obj);
  ```

- uuid模块----生成uuid号

  ```js
  const uuid=require('uuid/v4');   //需安装后引入
  console.log(uuid().replace(/\-/g, ''))
  ```

- stream模块(流)----读取流，写入流，读写流(压缩，加密)

  ```js
  const fs=require('fs');   
  let rs=fs.createReadStream('www/1.html');   //创建一个读取流
  let ws=fs.createWriteStream('www/2.html');  //创建一个写入流
  
  rs.pipe(ws);  //通过管道符pipe将读取流传入写入流
  
  rs.on('error', err=>{  //读取错误触发
    console.log('读取失败');
  });
  ws.on('end', ()=>{console.log('读取完成')})
  ws.on('error', err=>{console.log('写入失败')})
  ws.on('finish', ()=>{console.log('写入完成')});
  
  // 通过流对读取文件压缩
  const fs=require('fs');
  const zlib=require('zlib');
  
  let gz=zlib.createGzip();
  let rs=fs.createReadStream('www/2.png');
  let ws=fs.createWriteStream('www/2.png.gz');
  rs.pipe(gz).pipe(ws);
  ```

- zlib压缩模块（需设置响应头）

  ```js
  const http=require('http');
  const fs=require('fs');
  const url=require('url');
  const zlib=require('zlib');  //引入压缩模块
  
  http.createServer((req, res)=>{
    let {pathname, query}=url.parse(req.url, true);
    res.setHeader('Content-Encoding', 'gzip');  //需设置响应头，否则浏览器无法正常解析
  
    let rs=fs.createReadStream(`www${pathname}`); //创建读取流
    let gz=zlib.createGzip();  //创建压缩
  
    rs.pipe(gz).pipe(res); //通过管道将读取流压缩，并返回响应
  
    rs.on('error', function (){
      res.writeHeader(404);
      res.write('not found');
      res.end();
    });
  }).listen(8080);
  ```

- dns模块

  ```js
  const dns=require('dns'); 
  
  dns.lookup('www.baidu.com', (err, data)=>{  //根据域名查ip
    if(err){
      console.log('错了');
    }else{
      console.log(data);
    }
  });
  
  let ip='111.206.223.206';  //根据ip查域名
  dns.lookupService(ip, 80, (err, data)=>{
    if(err){
      console.log('错了', err);
    }else{
      console.log(data);
    }
  })
  ```

- crypto加密模块

  ```js
  const crypto=require('crypto');
  let hash=crypto.createHash('md5');  //md5  sha1  sha256  sha512  ripemd160
  //hash.update()方法将字符串相加，然后在hash.digest()将字符串加密返回
  //hash.update('abcdef'); 一次和分开写是一样效果
  hash.update('abc');
  hash.update('def'); 
  console.log(hash.digest('hex')); //以16进度输出
  ```

- assert断言

  ```js
  const assert=require('assert');
  function calc(a, b){  //对参数校验，不符合要求抛出错误
    assert(typeof a=='number' && typeof b=='number', '除法中两个东西，都得是数字');
    assert(b!=0, '分母不能是0');
    return a/b;
  }
  console.log(div('a c', 0));
  ```

## 3.2 处理post请求方法

```js
let server=http.createServer((req, res)=>{
  //GET数据获取方法
  let {pathname, query}=url.parse(req.url, true);
  //POST数据获取方法
  let aBuffer=[];   //使用数组保存post提交的数据
  req.on('data', data=>{
    aBuffer.push(data);
  });
  req.on('end', ()=>{
    let data=Buffer.concat(aBuffer); //提交完成后将数据保存在Buffer中
    //post请求的请求头以'multipart/form-data'开头
    if(req.headers['content-type'].startsWith('multipart/form-data')){
      let post={};
      let files={};
      //提取分隔符
      const boundary='--'+req.headers['content-type'].split('; ')[1].split('=')[1];
      //第一步、用分隔符切分
      let arr=data.split(boundary);
      //第二步、扔掉头尾(<>、<--\r\n>)
      arr.shift();
      arr.pop();
      //第三步、每一项的头尾扔掉(\r\n....\r\n)
      arr=arr.map(item=>item.slice(2, item.length-2));
      //第四步、找第一个"\r\n\r\n"，一切两半——前一半:信息，后一半:数据
      arr.forEach(item=>{
        let n=item.indexOf('\r\n\r\n');
        let info=item.slice(0, n);
        let data=item.slice(n+4);
        info=info.toString();
        let total=0;
        let complete=0;
        if(info.indexOf('\r\n')==-1){   //只有一行——普通数据
          let key=common.parseInfo(info).name;
          let val=data.toString();
          post[key]=val;
        }else{                          //两行——文件数据
          total++;
          let json=common.parseInfo(info);
          let key=json.name;
          let filename=json.filename;
          let type=json['Content-Type'];
          let filepath=`upload/${uuid().replace(/\-/g, '')}${path.extname(filename)}`;
          files[key]={filename, type, filepath};
          fs.writeFile(filepath, data, err=>{
            if(err){
              console.log('文件写入失败');
            }else{
              console.log('写入完成');
              complete++;
              console.log(post, files);
            }
          });
        }
      });
    }else{      //urlencoded
      let post=querystring.parse(data.toString());
      console.log(post);
    }
  });
});
server.listen(8080);
```

## 3.3 基于events的router

1. 原理

   ```js
   const Event=require('events').EventEmitter;  //EventEmitter——事件队列
   let ev=new Event();
   //ev监听
   ev.on('blue', (a,b,c,d)=>{
     console.log('接收到了1个事件：', a, b, c, d);
   });
   ev.on('blue', (a,b,c,d)=>{    //相同事件名可再次触发
     console.log('接收到了2个事件：', a, b, c, d);
   });
   
   //ev触发
   let res=ev.emit('blue', 12, 5, 8, 99);  //返回是否触发成功
   console.log('emit', res);
   ```

2. router文件

   ```js
   //router.js
   const Event=require('events').EventEmitter;
   module.exports=new Event();
   ```

3. 主文件（定义send方法，获取入参并触发相关方法）

   ```js
   const http=require('http');
   const fs=require('fs');
   const url=require('url');
   const router=require('./libs/router'); //导入自定义的router
   const zlib=require('zlib');
   
   http.createServer((req, res)=>{
     let {pathname, query}=url.parse(req.url, true); //获取入参
     req.query=query;   //将获取入参挂在req上
   
     res.send=function (data){  //给res增加一个send方法
       if(!(data instanceof Buffer) && typeof data!='string'){
         data=JSON.stringify(data);
       }
       res.write(data);
     }
   
     //不是一个接口处理
     if(false==router.emit(pathname, req, res)){  //pathname没有触发成功
       let rs=fs.createReadStream(`www${pathname}`);  //2.读取文件
       let gz=zlib.createGzip();
       res.setHeader('Content-Encoding', 'gzip');
       rs.pipe(gz).pipe(res);
       rs.on('error', err=>{
         //3.读取失败
         res.writeHeader(404);
         res.write('not found');
         res.end();
       });
     }else{  //是接口，处理方法相同
     }
   }).listen(8080);
   ```

4. 处理路由文件

   ```js
   const router=require('./router'); //导入上述router文件
   router.on('/login', (req, res)=>{
     let {user, pass}=req.query; //获取挂在req上的入参
     res.send({code: 0, msg: '登陆成功'}); //使用res上定义的send方法
     res.end();
   });
   router.on('/reg', (req, res)=>{
     let {user, pass}=req.query;
       res.send({code: 0, msg: '注册成功'});
       res.end();
     }
   });
   ```

## 3.4 ejs使用

<%=   输出文字——转义输出(html标签->html实体)
<%-   输出html——非转义输出(html标签->原样)    -%>

```js
const express=require('express');
const consolidate=require('consolidate');   //安装并引入模版引擎管理模块
let server=express();
server.listen(8080);

//1.选择一种模板引擎
server.engine('html', consolidate.ejs);   //该模块指定要使用的模版引擎
//2.指定模板文件的扩展名
server.set('view engine', 'ejs');
//3.指定模板文件的路径
server.set('views', './template');

server.get('/aaa', (req, res)=>{
  res.render('2', {arr: [12, 5, 88, 99]});
});
```

## 3.5 使用multer上传文件

```js
const multer=require('multer'); //安装并引入

//文件POST数据 配置
let multerObj=multer({dest: './upload/'});
server.use(multerObj.any());

//以post方式提交文件时会自动将文件保存指定目录中，并可在req中获取保存后相关的文件信息
for(let i=0;i<req.files.length;i++){  //上传多个文件
    req.files
    req.files[i].fieldname
    req.files[i].filename;
    req.files[i].path
}
```

## 3.6 KOA的使用

